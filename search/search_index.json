{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<pre>\n \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \n\u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \n\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\nCommand-line-interface Launcher for AIND Behavior Experiments\n</pre>"},{"location":"#clabe","title":"clabe","text":"<p>A library for building workflows for behavior experiments.</p> <p>\u26a0\ufe0f Caution: This repository is currently under active development and is subject to frequent changes. Features and APIs may evolve without prior notice.</p>"},{"location":"#installing-and-upgrading","title":"Installing and Upgrading","text":"<p>If you choose to clone the repository, you can install the package by running the following command from the root directory of the repository:</p> <pre><code>pip install .\n</code></pre> <p>Otherwise, you can use pip:</p> <pre><code>pip install aind-clabe\n</code></pre>"},{"location":"#getting-started-and-api-usage","title":"Getting started and API usage","text":"<p>The library provides a main class \"Launcher\" that can be used to create a linear workflow for behavior experiments. These workflows rely on modular interfaces that can be used to interact with various components of the experiment and other services. Some of these services are specific for AIND:</p> <ul> <li>aind-data-schema</li> <li>aind-data-schema-models</li> <li>aind-watchdog-service</li> <li>aind-data-mapper</li> </ul> <p>We will also try to scope all dependencies of the related to AIND Services to its own optional dependency list in the <code>./pyproject.toml</code> file of this repository. Therefore, in order to use this module, you will need to install these optional dependencies by running:</p> <p><code>uv sync --extra aind-services</code></p> <p>A basic example of how to use the Launcher class can be found in the <code>examples</code> directory of this repository.</p>"},{"location":"#contributors","title":"Contributors","text":"<p>Contributions to this repository are welcome! However, please ensure that your code adheres to the recommended DevOps practices below:</p>"},{"location":"#linting","title":"Linting","text":"<p>We use ruff as our primary linting tool.</p>"},{"location":"#testing","title":"Testing","text":"<p>Attempt to add tests when new features are added. To run the currently available tests, run <code>uv run -m unittest</code> from the root of the repository.</p>"},{"location":"#lock-files","title":"Lock files","text":"<p>We use uv to manage our lock files and therefore encourage everyone to use uv as a package manager as well.</p>"},{"location":"api/services/","title":"services","text":""},{"location":"api/services/#clabe.services.Service","title":"Service","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all services in the application. This may be needed in the future to ensure a common interface</p>"},{"location":"api/services/#clabe.services.ServiceSettings","title":"ServiceSettings","text":"<p>               Bases: <code>BaseSettings</code>, <code>ABC</code></p> <p>Base class for service settings with YAML configuration support.</p> <p>This class provides automatic YAML configuration loading using pydantic-settings. The configuration is loaded from files defined in KNOWN_CONFIG_FILES.</p> <p>Attributes:</p> Name Type Description <code>__yml_section__</code> <code>Optional[str]</code> <p>Optional class variable to override the config section name</p> Example <pre><code># Define a settings class\nclass MyServiceSettings(ServiceSettings):\n    __yml_section__: ClassVar[str] = \"my_service\"\n\n    host: str = \"localhost\"\n    port: int = 8080\n    enabled: bool = True\n\n# Usage will automatically load from YAML files\nsettings = MyServiceSettings()\n</code></pre>"},{"location":"api/services/#clabe.services.ServiceSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/apps/apps/","title":"apps","text":""},{"location":"api/apps/apps/#clabe.apps.App","title":"App","text":"<p>               Bases: <code>Service</code>, <code>ABC</code></p> <p>Abstract base class representing an application that can be run and managed.</p> <p>This class defines the interface for applications that can be executed and managed by the launcher. Subclasses must implement the abstract methods to define the specific behavior of the application.</p> <p>Methods:</p> Name Description <code>run</code> <p>Executes the application. Must be implemented by subclasses.</p> <code>output_from_result</code> <p>Optional[bool]) -&gt; Self: Processes and returns the output from the application's result. Must be implemented by subclasses.</p> <code>result</code> <p>Retrieves the result of the application's execution. Must be implemented by subclasses.</p> <code>add_app_settings</code> <p>Adds or updates application settings. Can be overridden by subclasses to provide specific behavior for managing application settings.</p> Notes <p>Subclasses must implement the abstract methods and property to define the specific behavior of the application.</p> Example <pre><code># Implement a custom app\nclass MyApp(App):\n    def run(self) -&gt; subprocess.CompletedProcess: return subprocess.run([\"echo\", \"hello\"])\n    def output_from_result(self, allow_stderr: Optional[bool]) -&gt; Self: return self\n    @property\n    def result(self) -&gt; subprocess.CompletedProcess: return self._result\n\napp = MyApp()\napp.run()\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.App.result","title":"result  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>result: CompletedProcess\n</code></pre> <p>Retrieves the result of the application's execution.</p> <p>This property should return the result of the application's execution.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the application's execution.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the application has not been run yet.</p>"},{"location":"api/apps/apps/#clabe.apps.App.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; CompletedProcess\n</code></pre> <p>Executes the application.</p> <p>This method should contain the logic to run the application and return the result of the execution.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the application's execution.</p> Source code in <code>src\\clabe\\apps\\_base.py</code> <pre><code>@abc.abstractmethod\ndef run(self) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Executes the application.\n\n    This method should contain the logic to run the application and return the result of the execution.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the application's execution.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.App.output_from_result","title":"output_from_result  <code>abstractmethod</code>","text":"<pre><code>output_from_result(*, allow_stderr: Optional[bool]) -&gt; Self\n</code></pre> <p>Processes and returns the output from the application's result.</p> <p>This method should process the result of the application's execution and return the output.</p> <p>Parameters:</p> Name Type Description Default <code>allow_stderr</code> <code>Optional[bool]</code> <p>Whether to allow stderr in the output.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The processed output.</p> Source code in <code>src\\clabe\\apps\\_base.py</code> <pre><code>@abc.abstractmethod\ndef output_from_result(self, *, allow_stderr: Optional[bool]) -&gt; Self:\n    \"\"\"\n    Processes and returns the output from the application's result.\n\n    This method should process the result of the application's execution and return the output.\n\n    Args:\n        allow_stderr (Optional[bool]): Whether to allow stderr in the output.\n\n    Returns:\n        Self: The processed output.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.App.add_app_settings","title":"add_app_settings","text":"<pre><code>add_app_settings(**kwargs) -&gt; Self\n</code></pre> <p>Adds or updates application settings.</p> <p>This method can be overridden by subclasses to provide specific behavior for managing application settings.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Keyword arguments for application settings.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The updated application instance.</p> Example <pre><code># Add application settings\napp.add_app_settings(debug=True, verbose=False)\n</code></pre> Source code in <code>src\\clabe\\apps\\_base.py</code> <pre><code>def add_app_settings(self, **kwargs) -&gt; Self:\n    \"\"\"\n    Adds or updates application settings.\n\n    This method can be overridden by subclasses to provide specific behavior for managing application settings.\n\n    Args:\n        **kwargs: Keyword arguments for application settings.\n\n    Returns:\n        Self: The updated application instance.\n\n    Example:\n        ```python\n        # Add application settings\n        app.add_app_settings(debug=True, verbose=False)\n        ```\n    \"\"\"\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.App.build_runner","title":"build_runner  <code>abstractmethod</code>","text":"<pre><code>build_runner(*args, **kwargs) -&gt; Callable[[Launcher], Any]\n</code></pre> <p>Builds a runner for the application. Expected to be implemented by subclasses.</p> Source code in <code>src\\clabe\\apps\\_base.py</code> <pre><code>@abc.abstractmethod\ndef build_runner(self, *args, **kwargs) -&gt; Callable[[Launcher], Any]:\n    \"\"\"Builds a runner for the application. Expected to be implemented by subclasses.\"\"\"\n    pass\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp","title":"AindBehaviorServicesBonsaiApp","text":"<pre><code>AindBehaviorServicesBonsaiApp(\n    settings: BonsaiAppSettings,\n    ui_helper: Optional[UiHelper] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>BonsaiApp</code></p> <p>Specialized Bonsai application for AIND behavior services integration.</p> <p>This class extends the base BonsaiApp to provide specific functionality for AIND behavior experiments, including automatic configuration of task logic, session, and rig paths for the Bonsai workflow.</p> Example <pre><code># Create an AIND behavior services Bonsai app\napp = AindBehaviorServicesBonsaiApp(workflow=\"behavior_workflow.bonsai\")\napp.add_app_settings(launcher=my_launcher)\napp.run()\n</code></pre> <p>Initializes the BonsaiApp instance.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>BonsaiAppSettings</code> <p>Settings for the Bonsai App.</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>UI helper instance. Defaults to DefaultUIHelper.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> Example <pre><code># Create and run a Bonsai app\napp = BonsaiApp(settings=BonsaiAppSettings(workflow=\"workflow.bonsai\"))\napp.run()\n# Create with custom settings\napp = BonsaiApp(\n    settings=BonsaiAppSettings(\n        workflow=\"workflow.bonsai\",\n        is_editor_mode=False,\n    )\n)\n</code></pre> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def __init__(\n    self,\n    /,\n    settings: BonsaiAppSettings,\n    ui_helper: Optional[UiHelper] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initializes the BonsaiApp instance.\n\n    Args:\n        settings (BonsaiAppSettings): Settings for the Bonsai App.\n        ui_helper (Optional[UiHelper]): UI helper instance. Defaults to DefaultUIHelper.\n        **kwargs: Additional keyword arguments.\n\n    Example:\n        ```python\n        # Create and run a Bonsai app\n        app = BonsaiApp(settings=BonsaiAppSettings(workflow=\"workflow.bonsai\"))\n        app.run()\n        # Create with custom settings\n        app = BonsaiApp(\n            settings=BonsaiAppSettings(\n                workflow=\"workflow.bonsai\",\n                is_editor_mode=False,\n            )\n        )\n        ```\n    \"\"\"\n    self.settings = settings\n    self._result: Optional[subprocess.CompletedProcess] = None\n    self.ui_helper = ui_helper if ui_helper is not None else DefaultUIHelper()\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.result","title":"result  <code>property</code>","text":"<pre><code>result: CompletedProcess\n</code></pre> <p>Returns the result of the Bonsai process execution.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the Bonsai process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the app has not been run yet.</p>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.run","title":"run","text":"<pre><code>run() -&gt; CompletedProcess\n</code></pre> <p>Runs the Bonsai process.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the Bonsai process execution.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If validation fails.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>@override\ndef run(self) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Runs the Bonsai process.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the Bonsai process execution.\n\n    Raises:\n        FileNotFoundError: If validation fails.\n    \"\"\"\n    self.validate()\n\n    if self.settings.is_editor_mode:\n        logger.warning(\"Bonsai is running in editor mode. Cannot assert successful completion.\")\n    logger.info(\"Bonsai process running...\")\n    proc = run_bonsai_process(\n        workflow_file=self.settings.workflow,\n        bonsai_exe=self.settings.executable,\n        is_editor_mode=self.settings.is_editor_mode,\n        is_start_flag=self.settings.is_start_flag,\n        additional_properties=self.settings.additional_properties,\n        cwd=self.settings.cwd,\n        timeout=self.settings.timeout,\n        print_cmd=self.settings.print_cmd,\n    )\n    self._result = proc\n    logger.info(\"Bonsai process completed.\")\n    return proc\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.output_from_result","title":"output_from_result","text":"<pre><code>output_from_result(*, allow_stderr: Optional[bool]) -&gt; Self\n</code></pre> <p>Processes the output from the Bonsai process result.</p> <p>Parameters:</p> Name Type Description Default <code>allow_stderr</code> <code>Optional[bool]</code> <p>Whether to allow stderr output.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The updated instance of BonsaiApp.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the process exits with an error.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>@override\ndef output_from_result(self, *, allow_stderr: Optional[bool]) -&gt; Self:\n    \"\"\"\n    Processes the output from the Bonsai process result.\n\n    Args:\n        allow_stderr (Optional[bool]): Whether to allow stderr output.\n\n    Returns:\n        Self: The updated instance of BonsaiApp.\n\n    Raises:\n        subprocess.CalledProcessError: If the process exits with an error.\n    \"\"\"\n    proc = self.result\n    try:\n        proc.check_returncode()\n    except subprocess.CalledProcessError:\n        self._log_process_std_output(\"Bonsai\", proc)\n        raise\n    else:\n        self._log_process_std_output(\"Bonsai\", proc)\n\n        if len(proc.stdout) &gt; 0:\n            logger.error(\"Bonsai process finished with errors.\")\n            if allow_stderr is None:\n                allow_stderr = self.ui_helper.prompt_yes_no_question(\"Would you like to see the error message?\")\n            if allow_stderr is False:\n                raise subprocess.CalledProcessError(1, proc.args)\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.build_runner","title":"build_runner","text":"<pre><code>build_runner(\n    allow_std_error: bool = False,\n) -&gt; Callable[[Launcher], Self]\n</code></pre> <p>Builds a runner function for the application.</p> <p>This method returns a callable that can be executed by the launcher to run the application.</p> <p>Parameters:</p> Name Type Description Default <code>allow_std_error</code> <code>bool</code> <p>Whether to allow stderr in the output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Launcher], Self]</code> <p>Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def build_runner(self, allow_std_error: bool = False) -&gt; Callable[[Launcher], Self]:\n    \"\"\"\n    Builds a runner function for the application.\n\n    This method returns a callable that can be executed by the launcher to run the application.\n\n    Args:\n        allow_std_error (bool): Whether to allow stderr in the output. Defaults to False.\n\n    Returns:\n        Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.\n    \"\"\"\n\n    def _run(launcher: Launcher):\n        \"\"\"Internal wrapper function\"\"\"\n        try:\n            self.add_app_settings(launcher=launcher)\n            self.run()\n            result = self.output_from_result(allow_stderr=allow_std_error)\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"App {self.__class__.__name__} failed with error: {e}\")\n            raise\n        return result\n\n    return _run\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.validate","title":"validate","text":"<pre><code>validate(*args, **kwargs) -&gt; bool\n</code></pre> <p>Validates the existence of required files and directories.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if validation is successful.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If any required file or directory is missing.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def validate(self, *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Validates the existence of required files and directories.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        bool: True if validation is successful.\n\n    Raises:\n        FileNotFoundError: If any required file or directory is missing.\n    \"\"\"\n    if not Path(self.settings.executable).exists():\n        raise FileNotFoundError(f\"Executable not found: {self.settings.executable}\")\n    if not Path(self.settings.workflow).exists():\n        raise FileNotFoundError(f\"Workflow file not found: {self.settings.workflow}\")\n    return True\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.AindBehaviorServicesBonsaiApp.add_app_settings","title":"add_app_settings","text":"<pre><code>add_app_settings(\n    *, launcher: Optional[Launcher] = None, **kwargs\n) -&gt; Self\n</code></pre> <p>Adds AIND behavior-specific application settings to the Bonsai workflow.</p> <p>This method automatically configures the TaskLogicPath, SessionPath, and RigPath properties for the Bonsai workflow based on the launcher's schema models.</p> <p>Parameters:</p> Name Type Description Default <code>launcher</code> <code>Optional[Launcher]</code> <p>The behavior launcher instance containing schema models</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The updated instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the required launcher argument is not provided</p> Example <pre><code># Add AIND behavior settings\napp.add_app_settings(launcher=my_launcher)\n</code></pre> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def add_app_settings(self, *, launcher: Optional[Launcher] = None, **kwargs) -&gt; Self:\n    \"\"\"\n    Adds AIND behavior-specific application settings to the Bonsai workflow.\n\n    This method automatically configures the TaskLogicPath, SessionPath, and RigPath\n    properties for the Bonsai workflow based on the launcher's schema models.\n\n    Args:\n        launcher: The behavior launcher instance containing schema models\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        Self: The updated instance\n\n    Raises:\n        ValueError: If the required launcher argument is not provided\n\n    Example:\n        ```python\n        # Add AIND behavior settings\n        app.add_app_settings(launcher=my_launcher)\n        ```\n    \"\"\"\n\n    if launcher is None:\n        raise ValueError(\"Missing required argument 'launcher'.\")\n\n    settings = {\n        \"TaskLogicPath\": os.path.abspath(\n            launcher.save_temp_model(model=launcher.get_task_logic(strict=True), directory=launcher.temp_dir)\n        ),\n        \"SessionPath\": os.path.abspath(\n            launcher.save_temp_model(model=launcher.get_session(strict=True), directory=launcher.temp_dir)\n        ),\n        \"RigPath\": os.path.abspath(\n            launcher.save_temp_model(model=launcher.get_rig(strict=True), directory=launcher.temp_dir)\n        ),\n    }\n    return super().add_app_settings(**settings)\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp","title":"BonsaiApp","text":"<pre><code>BonsaiApp(\n    settings: BonsaiAppSettings,\n    ui_helper: Optional[UiHelper] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>App</code></p> <p>A class to manage the execution of Bonsai workflows.</p> <p>Attributes:</p> Name Type Description <code>settings</code> <code>BonsaiAppSettings</code> <p>Settings for the Bonsai App</p> <code>ui_helper</code> <code>UiHelper</code> <p>Helper for user interface interactions.</p> <code>_result</code> <code>Optional[CompletedProcess]</code> <p>Result of the Bonsai process execution.</p> <p>Initializes the BonsaiApp instance.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>BonsaiAppSettings</code> <p>Settings for the Bonsai App.</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>UI helper instance. Defaults to DefaultUIHelper.</p> <code>None</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> Example <pre><code># Create and run a Bonsai app\napp = BonsaiApp(settings=BonsaiAppSettings(workflow=\"workflow.bonsai\"))\napp.run()\n# Create with custom settings\napp = BonsaiApp(\n    settings=BonsaiAppSettings(\n        workflow=\"workflow.bonsai\",\n        is_editor_mode=False,\n    )\n)\n</code></pre> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def __init__(\n    self,\n    /,\n    settings: BonsaiAppSettings,\n    ui_helper: Optional[UiHelper] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initializes the BonsaiApp instance.\n\n    Args:\n        settings (BonsaiAppSettings): Settings for the Bonsai App.\n        ui_helper (Optional[UiHelper]): UI helper instance. Defaults to DefaultUIHelper.\n        **kwargs: Additional keyword arguments.\n\n    Example:\n        ```python\n        # Create and run a Bonsai app\n        app = BonsaiApp(settings=BonsaiAppSettings(workflow=\"workflow.bonsai\"))\n        app.run()\n        # Create with custom settings\n        app = BonsaiApp(\n            settings=BonsaiAppSettings(\n                workflow=\"workflow.bonsai\",\n                is_editor_mode=False,\n            )\n        )\n        ```\n    \"\"\"\n    self.settings = settings\n    self._result: Optional[subprocess.CompletedProcess] = None\n    self.ui_helper = ui_helper if ui_helper is not None else DefaultUIHelper()\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.result","title":"result  <code>property</code>","text":"<pre><code>result: CompletedProcess\n</code></pre> <p>Returns the result of the Bonsai process execution.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the Bonsai process.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the app has not been run yet.</p>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.add_app_settings","title":"add_app_settings","text":"<pre><code>add_app_settings(**kwargs)\n</code></pre> <p>Adds application-specific settings to the additional properties.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <p>The updated instance of BonsaiApp.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>@override\ndef add_app_settings(self, **kwargs):\n    \"\"\"\n    Adds application-specific settings to the additional properties.\n\n    Args:\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Self: The updated instance of BonsaiApp.\n    \"\"\"\n\n    if self.settings.additional_properties is not None:\n        self.settings.additional_properties.update(**kwargs)\n    else:\n        self.settings.additional_properties = kwargs\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.validate","title":"validate","text":"<pre><code>validate(*args, **kwargs) -&gt; bool\n</code></pre> <p>Validates the existence of required files and directories.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional positional arguments.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if validation is successful.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If any required file or directory is missing.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def validate(self, *args, **kwargs) -&gt; bool:\n    \"\"\"\n    Validates the existence of required files and directories.\n\n    Args:\n        *args: Additional positional arguments.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        bool: True if validation is successful.\n\n    Raises:\n        FileNotFoundError: If any required file or directory is missing.\n    \"\"\"\n    if not Path(self.settings.executable).exists():\n        raise FileNotFoundError(f\"Executable not found: {self.settings.executable}\")\n    if not Path(self.settings.workflow).exists():\n        raise FileNotFoundError(f\"Workflow file not found: {self.settings.workflow}\")\n    return True\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.run","title":"run","text":"<pre><code>run() -&gt; CompletedProcess\n</code></pre> <p>Runs the Bonsai process.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the Bonsai process execution.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If validation fails.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>@override\ndef run(self) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Runs the Bonsai process.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the Bonsai process execution.\n\n    Raises:\n        FileNotFoundError: If validation fails.\n    \"\"\"\n    self.validate()\n\n    if self.settings.is_editor_mode:\n        logger.warning(\"Bonsai is running in editor mode. Cannot assert successful completion.\")\n    logger.info(\"Bonsai process running...\")\n    proc = run_bonsai_process(\n        workflow_file=self.settings.workflow,\n        bonsai_exe=self.settings.executable,\n        is_editor_mode=self.settings.is_editor_mode,\n        is_start_flag=self.settings.is_start_flag,\n        additional_properties=self.settings.additional_properties,\n        cwd=self.settings.cwd,\n        timeout=self.settings.timeout,\n        print_cmd=self.settings.print_cmd,\n    )\n    self._result = proc\n    logger.info(\"Bonsai process completed.\")\n    return proc\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.output_from_result","title":"output_from_result","text":"<pre><code>output_from_result(*, allow_stderr: Optional[bool]) -&gt; Self\n</code></pre> <p>Processes the output from the Bonsai process result.</p> <p>Parameters:</p> Name Type Description Default <code>allow_stderr</code> <code>Optional[bool]</code> <p>Whether to allow stderr output.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The updated instance of BonsaiApp.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the process exits with an error.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>@override\ndef output_from_result(self, *, allow_stderr: Optional[bool]) -&gt; Self:\n    \"\"\"\n    Processes the output from the Bonsai process result.\n\n    Args:\n        allow_stderr (Optional[bool]): Whether to allow stderr output.\n\n    Returns:\n        Self: The updated instance of BonsaiApp.\n\n    Raises:\n        subprocess.CalledProcessError: If the process exits with an error.\n    \"\"\"\n    proc = self.result\n    try:\n        proc.check_returncode()\n    except subprocess.CalledProcessError:\n        self._log_process_std_output(\"Bonsai\", proc)\n        raise\n    else:\n        self._log_process_std_output(\"Bonsai\", proc)\n\n        if len(proc.stdout) &gt; 0:\n            logger.error(\"Bonsai process finished with errors.\")\n            if allow_stderr is None:\n                allow_stderr = self.ui_helper.prompt_yes_no_question(\"Would you like to see the error message?\")\n            if allow_stderr is False:\n                raise subprocess.CalledProcessError(1, proc.args)\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiApp.build_runner","title":"build_runner","text":"<pre><code>build_runner(\n    allow_std_error: bool = False,\n) -&gt; Callable[[Launcher], Self]\n</code></pre> <p>Builds a runner function for the application.</p> <p>This method returns a callable that can be executed by the launcher to run the application.</p> <p>Parameters:</p> Name Type Description Default <code>allow_std_error</code> <code>bool</code> <p>Whether to allow stderr in the output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Launcher], Self]</code> <p>Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.</p> Source code in <code>src\\clabe\\apps\\_bonsai.py</code> <pre><code>def build_runner(self, allow_std_error: bool = False) -&gt; Callable[[Launcher], Self]:\n    \"\"\"\n    Builds a runner function for the application.\n\n    This method returns a callable that can be executed by the launcher to run the application.\n\n    Args:\n        allow_std_error (bool): Whether to allow stderr in the output. Defaults to False.\n\n    Returns:\n        Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.\n    \"\"\"\n\n    def _run(launcher: Launcher):\n        \"\"\"Internal wrapper function\"\"\"\n        try:\n            self.add_app_settings(launcher=launcher)\n            self.run()\n            result = self.output_from_result(allow_stderr=allow_std_error)\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"App {self.__class__.__name__} failed with error: {e}\")\n            raise\n        return result\n\n    return _run\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.BonsaiAppSettings","title":"BonsaiAppSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the BonsaiApp.</p> <p>Attributes:</p> Name Type Description <code>workflow</code> <code>PathLike</code> <p>Path to the Bonsai workflow file.</p> <code>executable</code> <code>PathLike</code> <p>Path to the Bonsai executable.</p> <code>is_editor_mode</code> <code>bool</code> <p>Whether to run Bonsai in editor mode.</p> <code>is_start_flag</code> <code>bool</code> <p>Whether to use the start flag when running Bonsai.</p> <code>additional_properties</code> <code>Optional[Dict[str, str]]</code> <p>Additional properties to pass to Bonsai.</p> <code>cwd</code> <code>Optional[PathLike]</code> <p>Working directory for the Bonsai process.</p> <code>timeout</code> <code>Optional[float]</code> <p>Timeout for the Bonsai process.</p> <code>print_cmd</code> <code>bool</code> <p>Whether to print the command being executed.</p>"},{"location":"api/apps/apps/#clabe.apps.BonsaiAppSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp","title":"CurriculumApp","text":"<pre><code>CurriculumApp(settings: CurriculumSettings)\n</code></pre> <p>               Bases: <code>App</code></p> <p>A curriculum application that manages the execution of behavior curriculum scripts.</p> <p>This class facilitates running curriculum modules within a managed Python environment, handling trainer state input/output and data directory management for curriculum processing.</p> <p>Attributes:</p> Name Type Description <code>_settings</code> <p>The curriculum settings configuration</p> <code>_python_script_app</code> <p>Internal Python script application for execution</p> Example <pre><code># Create and run a curriculum app\nsettings = CurriculumSettings(entry=\"/path/to/curriculum\")\napp = CurriculumApp(settings)\napp.run()\n\n# Use with launcher for automated curriculum processing\nlauncher.register_callable(app.build_runner(input_state_promise))\n</code></pre> <p>Initializes the CurriculumApp with the specified settings.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>CurriculumSettings</code> <p>Configuration settings for the curriculum application</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If pyproject.toml cannot be found in parent directories</p> Example <pre><code>settings = CurriculumSettings(\n    entry_point=\"/path/to/curriculum/module\",\n    data_directory=\"/data/session\"\n)\napp = CurriculumApp(settings)\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def __init__(self, settings: CurriculumSettings):\n    \"\"\"\n    Initializes the CurriculumApp with the specified settings.\n\n    Args:\n        settings: Configuration settings for the curriculum application\n\n    Raises:\n        FileNotFoundError: If pyproject.toml cannot be found in parent directories\n\n    Example:\n        ```python\n        settings = CurriculumSettings(\n            entry_point=\"/path/to/curriculum/module\",\n            data_directory=\"/data/session\"\n        )\n        app = CurriculumApp(settings)\n        ```\n    \"\"\"\n    self._settings = settings\n\n    self._python_script_app = PythonScriptApp(\n        script=settings.script, project_directory=settings.project_directory, extra_uv_arguments=\"-q\"\n    )\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.result","title":"result  <code>property</code>","text":"<pre><code>result: CompletedProcess\n</code></pre> <p>Retrieves the result of the curriculum execution.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the curriculum script execution</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the curriculum has not been run yet</p> Example <pre><code># Get execution result after running\napp.run()\nresult = app.result\nprint(f\"Return code: {result.returncode}\")\nprint(f\"Output: {result.stdout}\")\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.run","title":"run","text":"<pre><code>run() -&gt; CompletedProcess\n</code></pre> <p>Executes the curriculum module with the configured settings.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the curriculum execution</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If input_trainer_state or data_directory is not set</p> <code>CalledProcessError</code> <p>If the curriculum script execution fails</p> Example <pre><code># Set required parameters and run\napp._settings.input_trainer_state = \"/path/to/trainer_state.json\"\napp._settings.data_directory = \"/path/to/data\"\nresult = app.run()\nprint(f\"Exit code: {result.returncode}\")\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def run(self) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Executes the curriculum module with the configured settings.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the curriculum execution\n\n    Raises:\n        ValueError: If input_trainer_state or data_directory is not set\n        subprocess.CalledProcessError: If the curriculum script execution fails\n\n    Example:\n        ```python\n        # Set required parameters and run\n        app._settings.input_trainer_state = \"/path/to/trainer_state.json\"\n        app._settings.data_directory = \"/path/to/data\"\n        result = app.run()\n        print(f\"Exit code: {result.returncode}\")\n        ```\n    \"\"\"\n    if self._settings.input_trainer_state is None:\n        raise ValueError(\"Input trainer state is not set.\")\n    if self._settings.data_directory is None:\n        raise ValueError(\"Data directory is not set.\")\n\n    kwargs: dict[str, t.Any] = {  # Must use kebab casing\n        \"data-directory\": f'\"{self._settings.data_directory}\"',\n        \"input-trainer-state\": f'\"{self._settings.input_trainer_state}\"',\n    }\n    if self._settings.curriculum is not None:\n        kwargs[\"curriculum\"] = f'\"{self._settings.curriculum}\"'\n\n    self._python_script_app.add_app_settings(**kwargs)\n    return self._python_script_app.run()\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.output_from_result","title":"output_from_result","text":"<pre><code>output_from_result(\n    *, allow_stderr: bool | None = None\n) -&gt; Self\n</code></pre> <p>Processes the output from the curriculum execution result.</p> <p>Parameters:</p> Name Type Description Default <code>allow_stderr</code> <code>bool | None</code> <p>Whether to allow stderr in the output. If None, uses default behavior</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current CurriculumApp instance</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the process failed or stderr is present when not allowed</p> Example <pre><code># Process output and handle errors\ntry:\n    app.output_from_result(allow_stderr=True)\n    print(\"Curriculum completed successfully\")\nexcept subprocess.CalledProcessError as e:\n    print(f\"Curriculum failed: {e}\")\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def output_from_result(self, *, allow_stderr: bool | None = None) -&gt; t.Self:\n    \"\"\"\n    Processes the output from the curriculum execution result.\n\n    Args:\n        allow_stderr: Whether to allow stderr in the output. If None, uses default behavior\n\n    Returns:\n        Self: The current CurriculumApp instance\n\n    Raises:\n        subprocess.CalledProcessError: If the process failed or stderr is present when not allowed\n\n    Example:\n        ```python\n        # Process output and handle errors\n        try:\n            app.output_from_result(allow_stderr=True)\n            print(\"Curriculum completed successfully\")\n        except subprocess.CalledProcessError as e:\n            print(f\"Curriculum failed: {e}\")\n        ```\n    \"\"\"\n    self._python_script_app.output_from_result(allow_stderr=allow_stderr)\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.add_app_settings","title":"add_app_settings","text":"<pre><code>add_app_settings(**kwargs) -&gt; Self\n</code></pre> <p>Adds application-specific settings to the curriculum execution.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional keyword arguments to pass to the curriculum script</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current CurriculumApp instance</p> Example <pre><code># Add custom settings\napp.add_app_settings(\n    debug_mode=True,\n    log_level=\"DEBUG\",\n    custom_param=\"value\"\n)\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def add_app_settings(self, **kwargs) -&gt; t.Self:\n    \"\"\"\n    Adds application-specific settings to the curriculum execution.\n\n    Args:\n        **kwargs: Additional keyword arguments to pass to the curriculum script\n\n    Returns:\n        Self: The current CurriculumApp instance\n\n    Example:\n        ```python\n        # Add custom settings\n        app.add_app_settings(\n            debug_mode=True,\n            log_level=\"DEBUG\",\n            custom_param=\"value\"\n        )\n        ```\n    \"\"\"\n    self._python_script_app.add_app_settings(**kwargs)\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.build_runner","title":"build_runner","text":"<pre><code>build_runner(\n    input_trainer_state: Callable[[], TrainerState],\n    *,\n    session_directory: Optional[\n        Callable[[], PathLike]\n    ] = None,\n    allow_std_error: bool = False,\n) -&gt; Callable[[Launcher], CurriculumSuggestion]\n</code></pre> <p>Builds a runner function for curriculum execution within a launcher context.</p> <p>This method creates a callable that can be registered with a launcher to run the curriculum with proper data directory and trainer state management.</p> <p>Parameters:</p> Name Type Description Default <code>input_trainer_state</code> <code>Callable[[], TrainerState]</code> <p>Callable containing the trainer state to process</p> required <code>allow_std_error</code> <code>bool</code> <p>Whether to allow stderr output without raising an error</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Launcher], CurriculumSuggestion]</code> <p>Callable that takes a Launcher and returns a CurriculumSuggestion</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If curriculum execution fails</p> Note <p>This method overrides the base App.build_runner to provide curriculum-specific functionality and return type compatibility.</p> Example <pre><code># Register curriculum with launcher\ntrainer_state_promise = launcher.register_callable(get_trainer_state)\ncurriculum_runner = CurriculumApp.build_runner(trainer_state_promise, settings)\nlauncher.register_callable(curriculum_runner)\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def build_runner(\n    self,\n    input_trainer_state: t.Callable[[], aind_behavior_curriculum.trainer.TrainerState],\n    *,\n    session_directory: t.Optional[t.Callable[[], os.PathLike]] = None,\n    allow_std_error: bool = False,\n) -&gt; t.Callable[[Launcher], CurriculumSuggestion]:\n    \"\"\"\n    Builds a runner function for curriculum execution within a launcher context.\n\n    This method creates a callable that can be registered with a launcher to run\n    the curriculum with proper data directory and trainer state management.\n\n    Args:\n        input_trainer_state: Callable containing the trainer state to process\n        allow_std_error: Whether to allow stderr output without raising an error\n\n    Returns:\n        Callable that takes a Launcher and returns a CurriculumSuggestion\n\n    Raises:\n        subprocess.CalledProcessError: If curriculum execution fails\n\n    Note:\n        This method overrides the base App.build_runner to provide curriculum-specific\n        functionality and return type compatibility.\n\n    Example:\n        ```python\n        # Register curriculum with launcher\n        trainer_state_promise = launcher.register_callable(get_trainer_state)\n        curriculum_runner = CurriculumApp.build_runner(trainer_state_promise, settings)\n        launcher.register_callable(curriculum_runner)\n        ```\n    \"\"\"\n\n    def _run(launcher: Launcher) -&gt; CurriculumSuggestion:\n        if self._settings.data_directory is None:\n            self._settings.data_directory = session_directory() if session_directory else launcher.session_directory\n        if self._settings.input_trainer_state is None:\n            self._settings.input_trainer_state = Path(launcher.save_temp_model(input_trainer_state()))\n        try:\n            self.run()\n            self.output_from_result(allow_stderr=allow_std_error)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"App %s failed with error: %s\", self.__class__.__name__, e)\n            raise\n        return self.get_suggestion()\n\n    return _run\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumApp.get_suggestion","title":"get_suggestion","text":"<pre><code>get_suggestion() -&gt; CurriculumSuggestion\n</code></pre> <p>Parses and returns the curriculum suggestion from the execution result.</p> <p>Returns:</p> Name Type Description <code>CurriculumSuggestion</code> <code>CurriculumSuggestion</code> <p>Parsed curriculum output containing trainer state and metrics</p> <p>Raises:</p> Type Description <code>ValidationError</code> <p>If the result stdout cannot be parsed as valid JSON</p> <code>RuntimeError</code> <p>If the curriculum has not been run yet</p> Example <pre><code># Get suggestion after running curriculum\napp.run()\napp.output_from_result()\nsuggestion = app.get_suggestion()\nprint(f\"New trainer state: {suggestion.trainer_state}\")\nprint(f\"Metrics: {suggestion.metrics}\")\n</code></pre> Source code in <code>src\\clabe\\apps\\_curriculum.py</code> <pre><code>def get_suggestion(self) -&gt; CurriculumSuggestion:\n    \"\"\"\n    Parses and returns the curriculum suggestion from the execution result.\n\n    Returns:\n        CurriculumSuggestion: Parsed curriculum output containing trainer state and metrics\n\n    Raises:\n        pydantic.ValidationError: If the result stdout cannot be parsed as valid JSON\n        RuntimeError: If the curriculum has not been run yet\n\n    Example:\n        ```python\n        # Get suggestion after running curriculum\n        app.run()\n        app.output_from_result()\n        suggestion = app.get_suggestion()\n        print(f\"New trainer state: {suggestion.trainer_state}\")\n        print(f\"Metrics: {suggestion.metrics}\")\n        ```\n    \"\"\"\n    return CurriculumSuggestion.model_validate_json(self.result.stdout)\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumSettings","title":"CurriculumSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the CurriculumApp.</p> <p>Attributes:</p> Name Type Description <code>entry_point</code> <p>Path to the curriculum module (directory or file)</p> <code>input_trainer_state</code> <code>Optional[PathLike]</code> <p>Optional path to input TrainerState serialized file</p> <code>data_directory</code> <code>Optional[PathLike]</code> <p>Optional data directory for metrics calculation</p>"},{"location":"api/apps/apps/#clabe.apps.CurriculumSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.CurriculumSuggestion","title":"CurriculumSuggestion","text":"<p>               Bases: <code>BaseModel</code></p> <p>Model representing a curriculum suggestion with trainer state and metrics.</p> <p>This model encapsulates the output from a curriculum run, including the updated trainer state, performance metrics, and version information.</p> <p>Attributes:</p> Name Type Description <code>trainer_state</code> <code>SerializeAsAny[TrainerState]</code> <p>The updated trainer state after curriculum processing</p> <code>metrics</code> <code>SerializeAsAny[Metrics]</code> <p>Performance metrics from the curriculum run</p> <code>version</code> <code>str</code> <p>Version of the curriculum</p> <code>dsl_version</code> <code>str</code> <p>Version of the domain-specific language package used (aind-behavior-curriculum)</p>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp","title":"PythonScriptApp","text":"<pre><code>PythonScriptApp(\n    script: str,\n    additional_arguments: str = \"\",\n    project_directory: PathLike = Path(\".\"),\n    extra_uv_arguments: str = \"\",\n    optional_toml_dependencies: Optional[list[str]] = None,\n    append_python_exe: bool = False,\n    timeout: Optional[float] = None,\n)\n</code></pre> <p>               Bases: <code>App</code></p> <p>PythonScriptApp is a class that facilitates running Python scripts within a managed environment. It ensures the presence of a virtual environment, handles dependencies, and executes the script with specified arguments. Attributes:     script (str): The Python script to be executed.     _project_directory (os.PathLike): The directory where the project resides.     _timeout (Optional[float]): Timeout for the script execution.     _optional_toml_dependencies (list[str]): Additional TOML dependencies to be included.     _append_python_exe (bool): Whether to append the Python executable to the command.     _additional_arguments (str): Additional arguments to pass to the script.     _result (Optional[subprocess.CompletedProcess]): The result of the executed script. Methods:     __init_(script: str, additional_arguments: str, project_directory: os.PathLike, optional_toml_dependencies: Optional[list[str]], append_python_exe: bool, timeout: Optional[float]):         Initializes the PythonScriptApp with the specified parameters.     result:         Property that retrieves the result of the executed script. Raises an error if the script has not been run.     run() -&gt; subprocess.CompletedProcess:         Executes the Python script within the managed environment. Creates a virtual environment if one does not exist.     output_from_result(allow_stderr: Optional[bool]) -&gt; Self:         Processes the output of the executed script. Logs stdout and stderr, and optionally raises an error if stderr is present.     _log_process_std_output(process_name: str, proc: subprocess.CompletedProcess) -&gt; None:         Logs the stdout and stderr of a completed process.     _has_venv() -&gt; bool:         Checks if a virtual environment exists in the project directory.     create_environment(run_kwargs: Optional[dict[str, Any]]) -&gt; subprocess.CompletedProcess:         Creates a Python virtual environment using the <code>uv</code> tool.     _add_uv_project_directory() -&gt; str:         Constructs the <code>--directory</code> argument for the <code>uv</code> command.     _add_uv_optional_toml_dependencies() -&gt; str:         Constructs the <code>--extra</code> arguments for the <code>uv</code> command based on optional TOML dependencies.     _validate_uv() -&gt; bool:         Validates the presence of the <code>uv</code> executable. Raises an error if it is not installed. Example:     <pre><code># Create and run a Python script app\napp = PythonScriptApp(script=\"my_script.py\")\napp.run()\n# Create with additional arguments\napp = PythonScriptApp(script=\"my_script.py\", additional_arguments=\"foo\")\n</code></pre></p> <p>Initializes the PythonScriptApp with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>script</code> <code>str</code> <p>The Python script to be executed.</p> required <code>additional_arguments</code> <code>str</code> <p>Additional arguments to pass to the script.</p> <code>''</code> <code>project_directory</code> <code>PathLike</code> <p>The directory where the project resides.</p> <code>Path('.')</code> <code>extra_uv_arguments</code> <code>str</code> <p>Extra arguments to pass to the <code>uv</code> command.</p> <code>''</code> <code>optional_toml_dependencies</code> <code>Optional[list[str]]</code> <p>Additional TOML dependencies to include.</p> <code>None</code> <code>append_python_exe</code> <code>bool</code> <p>Whether to append the Python executable to the command.</p> <code>False</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout for the script execution.</p> <code>None</code> Example <pre><code># Initialize with basic script\napp = PythonScriptApp(script=\"test.py\")\n# Initialize with dependencies and arguments\napp = PythonScriptApp(\n    script=\"test.py\",\n    additional_arguments=\"--verbose\",\n    optional_toml_dependencies=[\"dev\", \"test\"]\n)\n</code></pre> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>def __init__(\n    self,\n    /,\n    script: str,\n    additional_arguments: str = \"\",\n    project_directory: os.PathLike = Path(\".\"),\n    extra_uv_arguments: str = \"\",\n    optional_toml_dependencies: Optional[list[str]] = None,\n    append_python_exe: bool = False,\n    timeout: Optional[float] = None,\n) -&gt; None:\n    \"\"\"\n    Initializes the PythonScriptApp with the specified parameters.\n\n    Args:\n        script (str): The Python script to be executed.\n        additional_arguments (str): Additional arguments to pass to the script.\n        project_directory (os.PathLike): The directory where the project resides.\n        extra_uv_arguments (str): Extra arguments to pass to the `uv` command.\n        optional_toml_dependencies (Optional[list[str]]): Additional TOML dependencies to include.\n        append_python_exe (bool): Whether to append the Python executable to the command.\n        timeout (Optional[float]): Timeout for the script execution.\n\n    Example:\n        ```python\n        # Initialize with basic script\n        app = PythonScriptApp(script=\"test.py\")\n        # Initialize with dependencies and arguments\n        app = PythonScriptApp(\n            script=\"test.py\",\n            additional_arguments=\"--verbose\",\n            optional_toml_dependencies=[\"dev\", \"test\"]\n        )\n        ```\n    \"\"\"\n    self._validate_uv()\n    self._script = script\n    self._project_directory = project_directory\n    self._timeout = timeout\n    self._optional_toml_dependencies = optional_toml_dependencies if optional_toml_dependencies else []\n    self._append_python_exe = append_python_exe\n    self._additional_arguments = additional_arguments\n    self._extra_uv_arguments = extra_uv_arguments\n\n    self._result: Optional[subprocess.CompletedProcess] = None\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.result","title":"result  <code>property</code>","text":"<pre><code>result: CompletedProcess\n</code></pre> <p>Retrieves the result of the executed script.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the executed script.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the script has not been run yet.</p>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.add_app_settings","title":"add_app_settings","text":"<pre><code>add_app_settings(**kwargs) -&gt; Self\n</code></pre> <p>Adds settings to the application</p> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>@override\ndef add_app_settings(self, **kwargs) -&gt; Self:\n    \"\"\"Adds settings to the application\"\"\"\n    self._additional_arguments = \" \".join([self._additional_arguments] + [f\"--{k} {v}\" for k, v in kwargs.items()])\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.run","title":"run","text":"<pre><code>run() -&gt; CompletedProcess\n</code></pre> <p>Executes the Python script within the managed environment.</p> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the executed script.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the script execution fails.</p> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>@override\ndef run(self) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Executes the Python script within the managed environment.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the executed script.\n\n    Raises:\n        subprocess.CalledProcessError: If the script execution fails.\n    \"\"\"\n    logger.info(\"Starting python script %s...\", self._script)\n\n    if not self._has_venv():\n        logger.warning(\"Python environment not found. Creating one...\")\n        self.create_environment()\n\n    _script = f\"{self._script} {self._additional_arguments}\"\n    _python_exe = \"python\" if self._append_python_exe else \"\"\n    command = f\"uv run {self._extra_uv_arguments} {self._add_uv_optional_toml_dependencies()} {self._add_uv_project_directory()} {_python_exe} {_script}\"\n\n    try:\n        proc = subprocess.run(\n            command,\n            shell=False,\n            capture_output=True,\n            text=True,\n            check=True,\n            cwd=Path(self._project_directory).resolve(),\n        )\n    except subprocess.CalledProcessError as e:\n        logger.error(\"Error running the Python script. %s\", e)\n        raise\n\n    logger.info(\"Python script completed.\")\n    self._result = proc\n    return proc\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.output_from_result","title":"output_from_result","text":"<pre><code>output_from_result(\n    *, allow_stderr: Optional[bool] = True\n) -&gt; Self\n</code></pre> <p>Processes the output of the executed script.</p> <p>Parameters:</p> Name Type Description Default <code>allow_stderr</code> <code>Optional[bool]</code> <p>Whether to allow stderr in the output.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the script execution fails or stderr is present when not allowed.</p> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>@override\ndef output_from_result(self, *, allow_stderr: Optional[bool] = True) -&gt; Self:\n    \"\"\"\n    Processes the output of the executed script.\n\n    Args:\n        allow_stderr (Optional[bool]): Whether to allow stderr in the output.\n\n    Returns:\n        Self: The current instance.\n\n    Raises:\n        subprocess.CalledProcessError: If the script execution fails or stderr is present when not allowed.\n    \"\"\"\n    proc = self.result\n    try:\n        proc.check_returncode()\n    except subprocess.CalledProcessError:\n        self._log_process_std_output(self._script, proc)\n        raise\n    else:\n        self._log_process_std_output(self._script, proc)\n        if len(proc.stderr) &gt; 0 and allow_stderr is False:\n            raise subprocess.CalledProcessError(1, proc.args)\n    return self\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.create_environment","title":"create_environment","text":"<pre><code>create_environment(\n    run_kwargs: Optional[dict[str, Any]] = None,\n) -&gt; CompletedProcess\n</code></pre> <p>Creates a Python virtual environment using the <code>uv</code> tool.</p> <p>Parameters:</p> Name Type Description Default <code>run_kwargs</code> <code>Optional[dict[str, Any]]</code> <p>Additional arguments for the <code>subprocess.run</code> call.</p> <code>None</code> <p>Returns:</p> Type Description <code>CompletedProcess</code> <p>subprocess.CompletedProcess: The result of the environment creation process.</p> <p>Raises:</p> Type Description <code>CalledProcessError</code> <p>If the environment creation fails.</p> Example <pre><code># Create a virtual environment\napp.create_environment()\n# Create with custom run kwargs\napp.create_environment(run_kwargs={\"timeout\": 30})\n</code></pre> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>def create_environment(self, run_kwargs: Optional[dict[str, Any]] = None) -&gt; subprocess.CompletedProcess:\n    \"\"\"\n    Creates a Python virtual environment using the `uv` tool.\n\n    Args:\n        run_kwargs (Optional[dict[str, Any]]): Additional arguments for the `subprocess.run` call.\n\n    Returns:\n        subprocess.CompletedProcess: The result of the environment creation process.\n\n    Raises:\n        subprocess.CalledProcessError: If the environment creation fails.\n\n    Example:\n        ```python\n        # Create a virtual environment\n        app.create_environment()\n        # Create with custom run kwargs\n        app.create_environment(run_kwargs={\"timeout\": 30})\n        ```\n    \"\"\"\n    logger.info(\"Creating Python environment with uv venv at %s...\", self._project_directory)\n    run_kwargs = run_kwargs or {}\n    try:\n        proc = subprocess.run(\n            f\"uv venv {self._add_uv_project_directory()} \",\n            shell=False,\n            capture_output=True,\n            text=True,\n            check=True,\n            cwd=self._project_directory,\n            **run_kwargs,\n        )\n        proc.check_returncode()\n    except subprocess.CalledProcessError as e:\n        logger.error(\"Error creating Python environment. %s\", e)\n        raise\n    return proc\n</code></pre>"},{"location":"api/apps/apps/#clabe.apps.PythonScriptApp.build_runner","title":"build_runner","text":"<pre><code>build_runner(\n    allow_std_error: bool = False,\n) -&gt; Callable[[Launcher], Self]\n</code></pre> <p>Builds a runner function for the application.</p> <p>This method returns a callable that can be executed by the launcher to run the application.</p> <p>Parameters:</p> Name Type Description Default <code>allow_std_error</code> <code>bool</code> <p>Whether to allow stderr in the output. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Callable[[Launcher], Self]</code> <p>Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.</p> Source code in <code>src\\clabe\\apps\\_python_script.py</code> <pre><code>def build_runner(self, allow_std_error: bool = False) -&gt; Callable[[Launcher], Self]:\n    \"\"\"\n    Builds a runner function for the application.\n\n    This method returns a callable that can be executed by the launcher to run the application.\n\n    Args:\n        allow_std_error (bool): Whether to allow stderr in the output. Defaults to False.\n\n    Returns:\n        Callable[[Launcher], Self]: A callable that takes a launcher instance and returns the application instance.\n    \"\"\"\n\n    def _run(launcher: Launcher):\n        \"\"\"Internal wrapper function\"\"\"\n        try:\n            self.run()\n            result = self.output_from_result(allow_stderr=allow_std_error)\n        except subprocess.CalledProcessError as e:\n            logger.error(f\"App {self.__class__.__name__} failed with error: {e}\")\n            raise\n        return result\n\n    return _run\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/","title":"data_mapper.aind_data_schema","text":""},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaDataMapper","title":"AindDataSchemaDataMapper","text":"<p>               Bases: <code>DataMapper[_TAdsObject]</code>, <code>ABC</code></p> <p>Abstract base class for mapping data to aind-data-schema objects.</p> <p>This class provides the foundation for mapping experimental data to AIND data schema formats, ensuring consistent structure and metadata handling across different data types.</p> <p>Attributes:</p> Name Type Description <code>session_name</code> <code>str</code> <p>The name of the session associated with the data</p> Example <pre><code># Example subclass implementing session_name\nclass MySessionMapper(AindDataSchemaDataMapper):\n    @property\n    def session_name(self) -&gt; str:\n        return \"session_001\"\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaDataMapper.session_name","title":"session_name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>session_name: str\n</code></pre> <p>Abstract property that must be implemented to return the session name.</p> <p>Subclasses must implement this property to provide the session name associated with the data being mapped.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the session</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaDataMapper.mapped","title":"mapped  <code>property</code>","text":"<pre><code>mapped: TMapTo\n</code></pre> <p>Retrieves the mapped data object.</p> <p>This property should return the successfully mapped data object. Implementations should ensure that mapping has been completed before returning the data.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data has not been mapped yet.</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaDataMapper.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map() -&gt; TMapTo\n</code></pre> <p>Maps data to the target schema or format.</p> <p>This method should contain the core logic for transforming input data into the target format specified by the TMapTo type parameter.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>@abc.abstractmethod\ndef map(self) -&gt; TMapTo:\n    \"\"\"\n    Maps data to the target schema or format.\n\n    This method should contain the core logic for transforming input data\n    into the target format specified by the TMapTo type parameter.\n\n    Returns:\n        TMapTo: The mapped data object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaDataMapper.is_mapped","title":"is_mapped","text":"<pre><code>is_mapped() -&gt; bool\n</code></pre> <p>Checks if the data has been successfully mapped.</p> <p>This method should verify whether the mapping operation has been completed and the data is available in the target format.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is mapped, False otherwise</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>def is_mapped(self) -&gt; bool:\n    \"\"\"\n    Checks if the data has been successfully mapped.\n\n    This method should verify whether the mapping operation has been completed\n    and the data is available in the target format.\n\n    Returns:\n        bool: True if the data is mapped, False otherwise\n    \"\"\"\n    return self._mapped is not None\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper","title":"AindDataSchemaSessionDataMapper","text":"<p>               Bases: <code>AindDataSchemaDataMapper[Session]</code>, <code>ABC</code></p> <p>Abstract base class for mapping session data to aind-data-schema Session objects.</p> <p>This class specializes the generic data mapper for session-specific data, providing the interface for converting experimental session data to the AIND data schema Session format.</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper.mapped","title":"mapped  <code>property</code>","text":"<pre><code>mapped: TMapTo\n</code></pre> <p>Retrieves the mapped data object.</p> <p>This property should return the successfully mapped data object. Implementations should ensure that mapping has been completed before returning the data.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data has not been mapped yet.</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper.session_name","title":"session_name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>session_name: str\n</code></pre> <p>Abstract property that must be implemented to return the session name.</p> <p>Subclasses must implement this property to provide the session name associated with the data being mapped.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the session</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper.session_schema","title":"session_schema","text":"<pre><code>session_schema() -&gt; Session\n</code></pre> <p>Returns the session schema for the mapped session data.</p> <p>This method should be implemented by subclasses to return the specific session schema that corresponds to the data being mapped.</p> <p>Returns:</p> Type Description <code>Session</code> <p>ads_session.Session: The session schema object</p> Source code in <code>src\\clabe\\data_mapper\\aind_data_schema.py</code> <pre><code>def session_schema(self) -&gt; Session:\n    \"\"\"\n    Returns the session schema for the mapped session data.\n\n    This method should be implemented by subclasses to return the specific\n    session schema that corresponds to the data being mapped.\n\n    Returns:\n        ads_session.Session: The session schema object\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method to return the session schema.\")\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map() -&gt; TMapTo\n</code></pre> <p>Maps data to the target schema or format.</p> <p>This method should contain the core logic for transforming input data into the target format specified by the TMapTo type parameter.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>@abc.abstractmethod\ndef map(self) -&gt; TMapTo:\n    \"\"\"\n    Maps data to the target schema or format.\n\n    This method should contain the core logic for transforming input data\n    into the target format specified by the TMapTo type parameter.\n\n    Returns:\n        TMapTo: The mapped data object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaSessionDataMapper.is_mapped","title":"is_mapped","text":"<pre><code>is_mapped() -&gt; bool\n</code></pre> <p>Checks if the data has been successfully mapped.</p> <p>This method should verify whether the mapping operation has been completed and the data is available in the target format.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is mapped, False otherwise</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>def is_mapped(self) -&gt; bool:\n    \"\"\"\n    Checks if the data has been successfully mapped.\n\n    This method should verify whether the mapping operation has been completed\n    and the data is available in the target format.\n\n    Returns:\n        bool: True if the data is mapped, False otherwise\n    \"\"\"\n    return self._mapped is not None\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper","title":"AindDataSchemaRigDataMapper","text":"<p>               Bases: <code>AindDataSchemaDataMapper[Rig]</code>, <code>ABC</code></p> <p>Abstract base class for mapping rig data to aind-data-schema Rig objects.</p> <p>This class specializes the generic data mapper for rig-specific data, providing the interface for converting experimental rig configurations to the AIND data schema Rig format.</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper.mapped","title":"mapped  <code>property</code>","text":"<pre><code>mapped: TMapTo\n</code></pre> <p>Retrieves the mapped data object.</p> <p>This property should return the successfully mapped data object. Implementations should ensure that mapping has been completed before returning the data.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data has not been mapped yet.</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper.session_name","title":"session_name  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>session_name: str\n</code></pre> <p>Abstract property that must be implemented to return the session name.</p> <p>Subclasses must implement this property to provide the session name associated with the data being mapped.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the session</p>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper.rig_schema","title":"rig_schema","text":"<pre><code>rig_schema() -&gt; Rig\n</code></pre> <p>Returns the rig schema for the mapped rig data.</p> <p>This method should be implemented by subclasses to return the specific rig schema that corresponds to the data being mapped.</p> <p>Returns:</p> Type Description <code>Rig</code> <p>ads_rig.Rig: The rig schema object</p> Source code in <code>src\\clabe\\data_mapper\\aind_data_schema.py</code> <pre><code>def rig_schema(self) -&gt; Rig:\n    \"\"\"\n    Returns the rig schema for the mapped rig data.\n\n    This method should be implemented by subclasses to return the specific\n    rig schema that corresponds to the data being mapped.\n\n    Returns:\n        ads_rig.Rig: The rig schema object\n    \"\"\"\n    raise NotImplementedError(\"Subclasses must implement this method to return the rig schema.\")\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map() -&gt; TMapTo\n</code></pre> <p>Maps data to the target schema or format.</p> <p>This method should contain the core logic for transforming input data into the target format specified by the TMapTo type parameter.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>@abc.abstractmethod\ndef map(self) -&gt; TMapTo:\n    \"\"\"\n    Maps data to the target schema or format.\n\n    This method should contain the core logic for transforming input data\n    into the target format specified by the TMapTo type parameter.\n\n    Returns:\n        TMapTo: The mapped data object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data_mapper/aind_data_schema/#clabe.data_mapper.aind_data_schema.AindDataSchemaRigDataMapper.is_mapped","title":"is_mapped","text":"<pre><code>is_mapped() -&gt; bool\n</code></pre> <p>Checks if the data has been successfully mapped.</p> <p>This method should verify whether the mapping operation has been completed and the data is available in the target format.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is mapped, False otherwise</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>def is_mapped(self) -&gt; bool:\n    \"\"\"\n    Checks if the data has been successfully mapped.\n\n    This method should verify whether the mapping operation has been completed\n    and the data is available in the target format.\n\n    Returns:\n        bool: True if the data is mapped, False otherwise\n    \"\"\"\n    return self._mapped is not None\n</code></pre>"},{"location":"api/data_mapper/data_mapper/","title":"data_mapper","text":""},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.DataMapper","title":"DataMapper","text":"<p>               Bases: <code>Service</code>, <code>ABC</code>, <code>Generic[TMapTo]</code></p> <p>Abstract base class for data mappers.</p> <p>This class defines the interface for mapping data from various sources to specific target formats or schemas. It provides a generic framework for data transformation and validation operations.</p> <p>Attributes:</p> Name Type Description <code>_mapped</code> <code>Optional[TMapTo]</code> <p>The mapped data object, set after successful mapping</p> Example <pre><code># Creating a custom data mapper\nclass MyDataMapper(DataMapper[MyTargetType]):\n    def map(self) -&gt; MyTargetType:\n        # Implementation specific mapping logic\n        self._mapped = MyTargetType(...)\n        return self._mapped\n\n    def is_mapped(self) -&gt; bool:\n        return self._mapped is not None\n\n    @property\n    def mapped(self) -&gt; MyTargetType:\n        if not self.is_mapped():\n            raise ValueError(\"Data not yet mapped\")\n        return self._mapped\n\n# Using the mapper\nmapper = MyDataMapper()\nresult = mapper.map()\nif mapper.is_mapped():\n    data = mapper.mapped\n</code></pre>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.DataMapper.mapped","title":"mapped  <code>property</code>","text":"<pre><code>mapped: TMapTo\n</code></pre> <p>Retrieves the mapped data object.</p> <p>This property should return the successfully mapped data object. Implementations should ensure that mapping has been completed before returning the data.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data has not been mapped yet.</p>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.DataMapper.map","title":"map  <code>abstractmethod</code>","text":"<pre><code>map() -&gt; TMapTo\n</code></pre> <p>Maps data to the target schema or format.</p> <p>This method should contain the core logic for transforming input data into the target format specified by the TMapTo type parameter.</p> <p>Returns:</p> Name Type Description <code>TMapTo</code> <code>TMapTo</code> <p>The mapped data object</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>@abc.abstractmethod\ndef map(self) -&gt; TMapTo:\n    \"\"\"\n    Maps data to the target schema or format.\n\n    This method should contain the core logic for transforming input data\n    into the target format specified by the TMapTo type parameter.\n\n    Returns:\n        TMapTo: The mapped data object\n    \"\"\"\n    pass\n</code></pre>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.DataMapper.is_mapped","title":"is_mapped","text":"<pre><code>is_mapped() -&gt; bool\n</code></pre> <p>Checks if the data has been successfully mapped.</p> <p>This method should verify whether the mapping operation has been completed and the data is available in the target format.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the data is mapped, False otherwise</p> Source code in <code>src\\clabe\\data_mapper\\_base.py</code> <pre><code>def is_mapped(self) -&gt; bool:\n    \"\"\"\n    Checks if the data has been successfully mapped.\n\n    This method should verify whether the mapping operation has been completed\n    and the data is available in the target format.\n\n    Returns:\n        bool: True if the data is mapped, False otherwise\n    \"\"\"\n    return self._mapped is not None\n</code></pre>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.get_cameras","title":"get_cameras","text":"<pre><code>get_cameras(\n    rig_instance: AindBehaviorRigModel,\n    exclude_without_video_writer: bool = True,\n) -&gt; Dict[str, CameraTypes]\n</code></pre> <p>Retrieves a dictionary of cameras from the given rig instance.</p> <p>Extracts camera information from camera controllers within the rig model, optionally filtering based on video writer availability.</p> <p>Parameters:</p> Name Type Description Default <code>rig_instance</code> <code>AindBehaviorRigModel</code> <p>The rig model instance containing camera controllers</p> required <code>exclude_without_video_writer</code> <code>bool</code> <p>If True, exclude cameras without a video writer</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, CameraTypes]</code> <p>Dict[str, CameraTypes]: A dictionary mapping camera names to their types</p> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def get_cameras(\n    rig_instance: AindBehaviorRigModel, exclude_without_video_writer: bool = True\n) -&gt; Dict[str, CameraTypes]:\n    \"\"\"\n    Retrieves a dictionary of cameras from the given rig instance.\n\n    Extracts camera information from camera controllers within the rig model,\n    optionally filtering based on video writer availability.\n\n    Args:\n        rig_instance: The rig model instance containing camera controllers\n        exclude_without_video_writer: If True, exclude cameras without a video writer\n\n    Returns:\n        Dict[str, CameraTypes]: A dictionary mapping camera names to their types\n    \"\"\"\n    cameras: dict[str, CameraTypes] = {}\n    camera_controllers = [x[1] for x in get_fields_of_type(rig_instance, CameraController)]\n\n    for controller in camera_controllers:\n        if exclude_without_video_writer:\n            these_cameras = {k: v for k, v in controller.cameras.items() if v.video_writer is not None}\n        else:\n            these_cameras = controller.cameras\n        cameras.update(these_cameras)\n    return cameras\n</code></pre>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.snapshot_bonsai_environment","title":"snapshot_bonsai_environment","text":"<pre><code>snapshot_bonsai_environment(\n    config_file: PathLike = Path(\"./bonsai/bonsai.config\"),\n) -&gt; Dict[str, str]\n</code></pre> <p>Captures a snapshot of the Bonsai environment from the given configuration file.</p> <p>Parses the Bonsai configuration file to extract information about installed packages and their versions, creating a snapshot of the Bonsai environment.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>PathLike</code> <p>Path to the Bonsai configuration file</p> <code>Path('./bonsai/bonsai.config')</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: A dictionary of package IDs and their versions</p> Example <pre><code># Capture Bonsai environment from default config:\nbonsai_env = snapshot_bonsai_environment()\n# Returns: {'Bonsai.Core': '2.7.0', 'Bonsai.Vision': '2.8.0', 'Bonsai.Spinnaker': '0.3.0', ...}\n\n# Capture from custom config file:\ncustom_env = snapshot_bonsai_environment(\"./custom/bonsai.config\")\n# Returns: {'Bonsai.Core': '2.6.0', 'Bonsai.Arduino': '2.7.0', ...}\n</code></pre> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def snapshot_bonsai_environment(\n    config_file: os.PathLike = Path(\"./bonsai/bonsai.config\"),\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Captures a snapshot of the Bonsai environment from the given configuration file.\n\n    Parses the Bonsai configuration file to extract information about installed\n    packages and their versions, creating a snapshot of the Bonsai environment.\n\n    Args:\n        config_file: Path to the Bonsai configuration file\n\n    Returns:\n        Dict[str, str]: A dictionary of package IDs and their versions\n\n    Example:\n        ```python\n        # Capture Bonsai environment from default config:\n        bonsai_env = snapshot_bonsai_environment()\n        # Returns: {'Bonsai.Core': '2.7.0', 'Bonsai.Vision': '2.8.0', 'Bonsai.Spinnaker': '0.3.0', ...}\n\n        # Capture from custom config file:\n        custom_env = snapshot_bonsai_environment(\"./custom/bonsai.config\")\n        # Returns: {'Bonsai.Core': '2.6.0', 'Bonsai.Arduino': '2.7.0', ...}\n        ```\n    \"\"\"\n    tree = ET.parse(Path(config_file))\n    root = tree.getroot()\n    packages = root.findall(\"Packages/Package\")\n    return {leaf.attrib[\"id\"]: leaf.attrib[\"version\"] for leaf in packages}\n</code></pre>"},{"location":"api/data_mapper/data_mapper/#clabe.data_mapper.snapshot_python_environment","title":"snapshot_python_environment","text":"<pre><code>snapshot_python_environment() -&gt; Dict[str, str]\n</code></pre> <p>Captures a snapshot of the current Python environment, including installed packages.</p> <p>Creates a record of all currently installed Python packages and their versions, useful for reproducibility and debugging purposes.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: A dictionary of package names and their versions</p> Example <pre><code># Capture the current Python environment:\nenv_snapshot = snapshot_python_environment()\n# Returns: {'numpy': '1.24.3', 'pandas': '2.0.1', 'aind-data-schema': '0.15.0', ...}\n\n# Use for debugging package versions:\npackages = snapshot_python_environment()\nprint(f\"NumPy version: {packages.get('numpy', 'Not installed')}\")\n# Prints: NumPy version: 1.24.3\n</code></pre> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def snapshot_python_environment() -&gt; Dict[str, str]:\n    \"\"\"\n    Captures a snapshot of the current Python environment, including installed packages.\n\n    Creates a record of all currently installed Python packages and their versions,\n    useful for reproducibility and debugging purposes.\n\n    Returns:\n        Dict[str, str]: A dictionary of package names and their versions\n\n    Example:\n        ```python\n        # Capture the current Python environment:\n        env_snapshot = snapshot_python_environment()\n        # Returns: {'numpy': '1.24.3', 'pandas': '2.0.1', 'aind-data-schema': '0.15.0', ...}\n\n        # Use for debugging package versions:\n        packages = snapshot_python_environment()\n        print(f\"NumPy version: {packages.get('numpy', 'Not installed')}\")\n        # Prints: NumPy version: 1.24.3\n        ```\n    \"\"\"\n    return {dist.name: dist.version for dist in metadata.distributions()}\n</code></pre>"},{"location":"api/data_mapper/helpers/","title":"data_mapper.helpers","text":""},{"location":"api/data_mapper/helpers/#clabe.data_mapper.helpers.get_cameras","title":"get_cameras","text":"<pre><code>get_cameras(\n    rig_instance: AindBehaviorRigModel,\n    exclude_without_video_writer: bool = True,\n) -&gt; Dict[str, CameraTypes]\n</code></pre> <p>Retrieves a dictionary of cameras from the given rig instance.</p> <p>Extracts camera information from camera controllers within the rig model, optionally filtering based on video writer availability.</p> <p>Parameters:</p> Name Type Description Default <code>rig_instance</code> <code>AindBehaviorRigModel</code> <p>The rig model instance containing camera controllers</p> required <code>exclude_without_video_writer</code> <code>bool</code> <p>If True, exclude cameras without a video writer</p> <code>True</code> <p>Returns:</p> Type Description <code>Dict[str, CameraTypes]</code> <p>Dict[str, CameraTypes]: A dictionary mapping camera names to their types</p> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def get_cameras(\n    rig_instance: AindBehaviorRigModel, exclude_without_video_writer: bool = True\n) -&gt; Dict[str, CameraTypes]:\n    \"\"\"\n    Retrieves a dictionary of cameras from the given rig instance.\n\n    Extracts camera information from camera controllers within the rig model,\n    optionally filtering based on video writer availability.\n\n    Args:\n        rig_instance: The rig model instance containing camera controllers\n        exclude_without_video_writer: If True, exclude cameras without a video writer\n\n    Returns:\n        Dict[str, CameraTypes]: A dictionary mapping camera names to their types\n    \"\"\"\n    cameras: dict[str, CameraTypes] = {}\n    camera_controllers = [x[1] for x in get_fields_of_type(rig_instance, CameraController)]\n\n    for controller in camera_controllers:\n        if exclude_without_video_writer:\n            these_cameras = {k: v for k, v in controller.cameras.items() if v.video_writer is not None}\n        else:\n            these_cameras = controller.cameras\n        cameras.update(these_cameras)\n    return cameras\n</code></pre>"},{"location":"api/data_mapper/helpers/#clabe.data_mapper.helpers.snapshot_python_environment","title":"snapshot_python_environment","text":"<pre><code>snapshot_python_environment() -&gt; Dict[str, str]\n</code></pre> <p>Captures a snapshot of the current Python environment, including installed packages.</p> <p>Creates a record of all currently installed Python packages and their versions, useful for reproducibility and debugging purposes.</p> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: A dictionary of package names and their versions</p> Example <pre><code># Capture the current Python environment:\nenv_snapshot = snapshot_python_environment()\n# Returns: {'numpy': '1.24.3', 'pandas': '2.0.1', 'aind-data-schema': '0.15.0', ...}\n\n# Use for debugging package versions:\npackages = snapshot_python_environment()\nprint(f\"NumPy version: {packages.get('numpy', 'Not installed')}\")\n# Prints: NumPy version: 1.24.3\n</code></pre> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def snapshot_python_environment() -&gt; Dict[str, str]:\n    \"\"\"\n    Captures a snapshot of the current Python environment, including installed packages.\n\n    Creates a record of all currently installed Python packages and their versions,\n    useful for reproducibility and debugging purposes.\n\n    Returns:\n        Dict[str, str]: A dictionary of package names and their versions\n\n    Example:\n        ```python\n        # Capture the current Python environment:\n        env_snapshot = snapshot_python_environment()\n        # Returns: {'numpy': '1.24.3', 'pandas': '2.0.1', 'aind-data-schema': '0.15.0', ...}\n\n        # Use for debugging package versions:\n        packages = snapshot_python_environment()\n        print(f\"NumPy version: {packages.get('numpy', 'Not installed')}\")\n        # Prints: NumPy version: 1.24.3\n        ```\n    \"\"\"\n    return {dist.name: dist.version for dist in metadata.distributions()}\n</code></pre>"},{"location":"api/data_mapper/helpers/#clabe.data_mapper.helpers.snapshot_bonsai_environment","title":"snapshot_bonsai_environment","text":"<pre><code>snapshot_bonsai_environment(\n    config_file: PathLike = Path(\"./bonsai/bonsai.config\"),\n) -&gt; Dict[str, str]\n</code></pre> <p>Captures a snapshot of the Bonsai environment from the given configuration file.</p> <p>Parses the Bonsai configuration file to extract information about installed packages and their versions, creating a snapshot of the Bonsai environment.</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>PathLike</code> <p>Path to the Bonsai configuration file</p> <code>Path('./bonsai/bonsai.config')</code> <p>Returns:</p> Type Description <code>Dict[str, str]</code> <p>Dict[str, str]: A dictionary of package IDs and their versions</p> Example <pre><code># Capture Bonsai environment from default config:\nbonsai_env = snapshot_bonsai_environment()\n# Returns: {'Bonsai.Core': '2.7.0', 'Bonsai.Vision': '2.8.0', 'Bonsai.Spinnaker': '0.3.0', ...}\n\n# Capture from custom config file:\ncustom_env = snapshot_bonsai_environment(\"./custom/bonsai.config\")\n# Returns: {'Bonsai.Core': '2.6.0', 'Bonsai.Arduino': '2.7.0', ...}\n</code></pre> Source code in <code>src\\clabe\\data_mapper\\helpers.py</code> <pre><code>def snapshot_bonsai_environment(\n    config_file: os.PathLike = Path(\"./bonsai/bonsai.config\"),\n) -&gt; Dict[str, str]:\n    \"\"\"\n    Captures a snapshot of the Bonsai environment from the given configuration file.\n\n    Parses the Bonsai configuration file to extract information about installed\n    packages and their versions, creating a snapshot of the Bonsai environment.\n\n    Args:\n        config_file: Path to the Bonsai configuration file\n\n    Returns:\n        Dict[str, str]: A dictionary of package IDs and their versions\n\n    Example:\n        ```python\n        # Capture Bonsai environment from default config:\n        bonsai_env = snapshot_bonsai_environment()\n        # Returns: {'Bonsai.Core': '2.7.0', 'Bonsai.Vision': '2.8.0', 'Bonsai.Spinnaker': '0.3.0', ...}\n\n        # Capture from custom config file:\n        custom_env = snapshot_bonsai_environment(\"./custom/bonsai.config\")\n        # Returns: {'Bonsai.Core': '2.6.0', 'Bonsai.Arduino': '2.7.0', ...}\n        ```\n    \"\"\"\n    tree = ET.parse(Path(config_file))\n    root = tree.getroot()\n    packages = root.findall(\"Packages/Package\")\n    return {leaf.attrib[\"id\"]: leaf.attrib[\"version\"] for leaf in packages}\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/","title":"data_transfer.aind_watchdog","text":""},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogSettings","title":"WatchdogSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the WatchdogDataTransferService.</p> <p>Attributes:</p> Name Type Description <code>destination</code> <code>Path</code> <p>The destination path for the data transfer.</p> <code>schedule_time</code> <code>Optional[time]</code> <p>The time to schedule the data transfer.</p> <code>project_name</code> <code>str</code> <p>The name of the project.</p> <code>platform</code> <code>Platform</code> <p>The platform of the project.</p> <code>capsule_id</code> <code>Optional[str]</code> <p>The capsule ID for the data transfer.</p> <code>script</code> <code>Optional[Dict[str, List[str]]]</code> <p>A dictionary of scripts to run.</p> <code>s3_bucket</code> <code>BucketType</code> <p>The S3 bucket to transfer the data to.</p> <code>mount</code> <code>Optional[str]</code> <p>The mount point for the data transfer.</p> <code>force_cloud_sync</code> <code>bool</code> <p>Whether to force a cloud sync.</p> <code>transfer_endpoint</code> <code>str</code> <p>The endpoint for the data transfer service.</p> <code>delete_modalities_source_after_success</code> <code>bool</code> <p>Whether to delete the source data after a successful transfer.</p> <code>extra_identifying_info</code> <code>Optional[dict]</code> <p>Extra identifying information for the data transfer.</p> <code>upload_tasks</code> <code>Optional[Any]</code> <p>Upload job configurations. Use the placeholder \"{{ destination }}\" to later reference the destination path.</p> <code>job_config</code> <code>str</code> <p>Job configuration name.</p>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService","title":"WatchdogDataTransferService","text":"<pre><code>WatchdogDataTransferService(\n    source: PathLike,\n    settings: WatchdogSettings,\n    *,\n    validate: bool = True,\n    session_name: Optional[str] = None,\n    ui_helper: Optional[UiHelper] = None,\n    email_from_experimenter_builder: Optional[\n        Callable[[str], str]\n    ] = lambda user_name: f\"{user_name}@alleninstitute.org\",\n)\n</code></pre> <p>               Bases: <code>DataTransfer[WatchdogSettings]</code>, <code>Generic[TSessionMapper]</code></p> <p>A data transfer service that uses the aind-watchdog-service to monitor and transfer data based on manifest configurations.</p> <p>This service integrates with the AIND data transfer infrastructure to automatically monitor directories for new data and transfer it to specified destinations with proper metadata handling and validation.</p> <p>Attributes:</p> Name Type Description <code>_source</code> <code>PathLike</code> <p>Source directory to monitor</p> <code>_settings</code> <code>WatchdogSettings</code> <p>Service settings containing destination and configuration</p> <code>_aind_session_data_mapper</code> <code>Optional[_TSessionMapper]</code> <p>Mapper for session data</p> <code>_ui_helper</code> <code>UiHelper</code> <p>UI helper for user prompts</p> Example <pre><code># Basic watchdog service setup:\nsettings = WatchdogSettings(\n    destination=\"//server/data/session_001\",\n    project_name=\"my_project\"\n)\nservice = WatchdogDataTransferService(\n    source=\"C:/data/session_001\",\n    settings=settings\n)\n\n# Full configuration with session mapper:\nsettings = WatchdogSettings(\n    destination=\"//server/data/session_001\",\n    project_name=\"behavior_study\",\n    schedule_time=datetime.time(hour=22, minute=30),\n    platform=Platform.BEHAVIOR,\n    force_cloud_sync=True\n)\nsession_mapper = MySessionMapper(session_data)\nservice = WatchdogDataTransferService(\n    source=\"C:/data/session_001\",\n    settings=settings\n)\nservice = service.with_aind_session_data_mapper(session_mapper)\nif service.validate():\n    service.transfer()\n</code></pre> <p>Initializes the WatchdogDataTransferService.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>PathLike</code> <p>The source directory or file to monitor</p> required <code>settings</code> <code>WatchdogSettings</code> <p>WatchdogSettings containing destination and configuration options</p> required <code>validate</code> <code>bool</code> <p>Whether to validate the project name</p> <code>True</code> <code>session_name</code> <code>Optional[str]</code> <p>Name of the session</p> <code>None</code> <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>UI helper for user prompts</p> <code>None</code> Example <pre><code># Basic initialization:\nsettings = WatchdogSettings(\n    destination=\"//server/archive/session_001\",\n    project_name=\"behavior_project\"\n)\nservice = WatchdogDataTransferService(\n    source=\"C:/data/session_001\",\n    settings=settings\n)\n\n# Advanced configuration:\nsettings = WatchdogSettings(\n    destination=\"//server/archive/session_001\",\n    project_name=\"behavior_project\",\n    schedule_time=datetime.time(hour=23),\n    platform=Platform.BEHAVIOR,\n    force_cloud_sync=True,\n    delete_modalities_source_after_success=True,\n    extra_identifying_info={\"experiment_type\": \"foraging\"}\n)\nservice = WatchdogDataTransferService(\n    source=\"C:/data/session_001\",\n    settings=settings\n)\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def __init__(\n    self,\n    source: PathLike,\n    settings: WatchdogSettings,\n    *,\n    validate: bool = True,\n    session_name: Optional[str] = None,\n    ui_helper: Optional[ui.UiHelper] = None,\n    email_from_experimenter_builder: Optional[\n        Callable[[str], str]\n    ] = lambda user_name: f\"{user_name}@alleninstitute.org\",\n) -&gt; None:\n    \"\"\"\n    Initializes the WatchdogDataTransferService.\n\n    Args:\n        source: The source directory or file to monitor\n        settings: WatchdogSettings containing destination and configuration options\n        validate: Whether to validate the project name\n        session_name: Name of the session\n        ui_helper: UI helper for user prompts\n\n    Example:\n        ```python\n        # Basic initialization:\n        settings = WatchdogSettings(\n            destination=\"//server/archive/session_001\",\n            project_name=\"behavior_project\"\n        )\n        service = WatchdogDataTransferService(\n            source=\"C:/data/session_001\",\n            settings=settings\n        )\n\n        # Advanced configuration:\n        settings = WatchdogSettings(\n            destination=\"//server/archive/session_001\",\n            project_name=\"behavior_project\",\n            schedule_time=datetime.time(hour=23),\n            platform=Platform.BEHAVIOR,\n            force_cloud_sync=True,\n            delete_modalities_source_after_success=True,\n            extra_identifying_info={\"experiment_type\": \"foraging\"}\n        )\n        service = WatchdogDataTransferService(\n            source=\"C:/data/session_001\",\n            settings=settings\n        )\n        ```\n    \"\"\"\n    self._settings = settings\n    self._source = source\n\n    self._aind_session_data_mapper: Optional[TSessionMapper] = None\n\n    _default_exe = os.environ.get(\"WATCHDOG_EXE\", None)\n    _default_config = os.environ.get(\"WATCHDOG_CONFIG\", None)\n\n    if _default_exe is None or _default_config is None:\n        raise ValueError(\"WATCHDOG_EXE and WATCHDOG_CONFIG environment variables must be defined.\")\n\n    self.executable_path = Path(_default_exe)\n    self.config_path = Path(_default_config)\n\n    self._watch_config: Optional[WatchConfig] = None\n    self._manifest_config: Optional[ManifestConfig] = None\n\n    self._validate_project_name = validate\n\n    if validate:\n        self.validate()\n\n    self._watch_config = WatchConfig.model_validate(self._read_yaml(self.config_path))\n\n    self._ui_helper = ui_helper or ui.DefaultUIHelper()\n    self._session_name = session_name\n    self._email_from_experimenter_builder = email_from_experimenter_builder\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.aind_session_data_mapper","title":"aind_session_data_mapper  <code>property</code>","text":"<pre><code>aind_session_data_mapper: TSessionMapper\n</code></pre> <p>Gets the aind-data-schema session data mapper.</p> <p>Returns:</p> Type Description <code>TSessionMapper</code> <p>The session data mapper</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data mapper is not set</p>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: TSettings\n</code></pre> <p>Returns the settings for the data transfer service.</p>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.with_aind_session_data_mapper","title":"with_aind_session_data_mapper","text":"<pre><code>with_aind_session_data_mapper(\n    value: TSessionMapper,\n) -&gt; WatchdogDataTransferService[TSessionMapper]\n</code></pre> <p>Sets the aind-data-schema session data mapper.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>TSessionMapper</code> <p>The data mapper to set</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided value is not a valid data mapper</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def with_aind_session_data_mapper(self, value: TSessionMapper) -&gt; \"WatchdogDataTransferService[TSessionMapper]\":\n    \"\"\"\n    Sets the aind-data-schema session data mapper.\n\n    Args:\n        value: The data mapper to set\n\n    Raises:\n        ValueError: If the provided value is not a valid data mapper\n    \"\"\"\n    self._aind_session_data_mapper = value\n    return self\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.transfer","title":"transfer","text":"<pre><code>transfer() -&gt; None\n</code></pre> <p>Executes the data transfer by generating a Watchdog manifest configuration.</p> <p>Creates and deploys a manifest configuration file that the watchdog service will use to monitor and transfer data according to the specified parameters.</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def transfer(self) -&gt; None:\n    \"\"\"\n    Executes the data transfer by generating a Watchdog manifest configuration.\n\n    Creates and deploys a manifest configuration file that the watchdog service\n    will use to monitor and transfer data according to the specified parameters.\n    \"\"\"\n    try:\n        if not self.is_running():\n            logger.warning(\"Watchdog service is not running. Attempting to start it.\")\n            try:\n                self.force_restart(kill_if_running=False)\n            except subprocess.CalledProcessError as e:\n                logger.error(\"Failed to start watchdog service. %s\", e)\n                raise RuntimeError(\"Failed to start watchdog service.\") from e\n            else:\n                if not self.is_running():\n                    logger.error(\"Failed to start watchdog service.\")\n                    raise RuntimeError(\"Failed to start watchdog service.\")\n                else:\n                    logger.info(\"Watchdog service restarted successfully.\")\n\n        logger.debug(\"Creating watchdog manifest config.\")\n\n        if not self.aind_session_data_mapper.is_mapped():\n            raise ValueError(\"Data mapper has not been mapped yet.\")\n\n        if _AIND_DATA_SCHEMA_PKG_VERSION.major &lt; 2:\n            logger.warning(\n                \"Using deprecated AIND data schema version %s. Consider upgrading.\", _AIND_DATA_SCHEMA_PKG_VERSION\n            )\n            self._manifest_config = self._create_manifest_config_from_ads_session(\n                ads_session=self.aind_session_data_mapper.mapped,\n                session_name=self._session_name,\n            )\n        else:\n            self._manifest_config = self._create_manifest_config_from_ads_acquisition(\n                ads_session=self.aind_session_data_mapper.mapped,\n                session_name=self._session_name,\n            )\n\n        if self._watch_config is None:\n            raise ValueError(\"Watchdog config is not set.\")\n\n        assert self._manifest_config.name is not None, \"Manifest config name must be set.\"\n        _manifest_path = self.dump_manifest_config(\n            path=Path(self._watch_config.flag_dir) / self._manifest_config.name\n        )\n        logger.info(\"Watchdog manifest config created successfully at %s.\", _manifest_path)\n\n    except (pydantic.ValidationError, ValueError, IOError) as e:\n        logger.error(\"Failed to create watchdog manifest config. %s\", e)\n        raise\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.validate","title":"validate","text":"<pre><code>validate() -&gt; bool\n</code></pre> <p>Validates the Watchdog service and its configuration.</p> <p>Checks for required executables, configuration files, service status, and project name validity.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the service is valid, False otherwise</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If required files are missing</p> <code>HTTPError</code> <p>If the project name validation fails</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"\n    Validates the Watchdog service and its configuration.\n\n    Checks for required executables, configuration files, service status,\n    and project name validity.\n\n    Returns:\n        True if the service is valid, False otherwise\n\n    Raises:\n        FileNotFoundError: If required files are missing\n        HTTPError: If the project name validation fails\n    \"\"\"\n    logger.debug(\"Attempting to validate Watchdog service.\")\n    if not self.executable_path.exists():\n        raise FileNotFoundError(f\"Executable not found at {self.executable_path}\")\n    if not self.config_path.exists():\n        raise FileNotFoundError(f\"Config file not found at {self.config_path}\")\n\n    if not self.is_running():\n        logger.warning(\n            \"Watchdog service is not running. \\\n                            After the session is over, \\\n                            the launcher will attempt to forcefully restart it\"\n        )\n        return False\n\n    if self.settings.project_name is None:\n        logger.warning(\"Watchdog project name is not set. Skipping validation.\")\n    else:\n        try:\n            _valid_proj = self.is_valid_project_name()\n            if not _valid_proj:\n                logger.warning(\"Watchdog project name is not valid.\")\n        except HTTPError as e:\n            logger.error(\"Failed to fetch project names from endpoint. %s\", e)\n            raise\n        return _valid_proj\n\n    return True\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.is_valid_project_name","title":"is_valid_project_name","text":"<pre><code>is_valid_project_name() -&gt; bool\n</code></pre> <p>Checks if the project name is valid by querying the metadata service.</p> <p>Validates the project name against the list of known projects from the AIND metadata service.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the project name is valid, False otherwise</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def is_valid_project_name(self) -&gt; bool:\n    \"\"\"\n    Checks if the project name is valid by querying the metadata service.\n\n    Validates the project name against the list of known projects from\n    the AIND metadata service.\n\n    Returns:\n        True if the project name is valid, False otherwise\n    \"\"\"\n    project_names = self._get_project_names()\n    return self._settings.project_name in project_names\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.is_running","title":"is_running","text":"<pre><code>is_running() -&gt; bool\n</code></pre> <p>Checks if the Watchdog service is currently running.</p> <p>Uses system process monitoring to determine if the watchdog executable is currently active.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the service is running, False otherwise</p> Example <pre><code># Check service status:\nsettings = WatchdogSettings(\n    destination=\"//server/data\",\n    project_name=\"my_project\"\n)\nservice = WatchdogDataTransferService(source=\"C:/data\", settings=settings)\nif service.is_running():\n    print(\"Watchdog service is active\")\nelse:\n    print(\"Watchdog service is not running\")\n    service.force_restart()\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def is_running(self) -&gt; bool:\n    \"\"\"\n    Checks if the Watchdog service is currently running.\n\n    Uses system process monitoring to determine if the watchdog executable\n    is currently active.\n\n    Returns:\n        True if the service is running, False otherwise\n\n    Example:\n        ```python\n        # Check service status:\n        settings = WatchdogSettings(\n            destination=\"//server/data\",\n            project_name=\"my_project\"\n        )\n        service = WatchdogDataTransferService(source=\"C:/data\", settings=settings)\n        if service.is_running():\n            print(\"Watchdog service is active\")\n        else:\n            print(\"Watchdog service is not running\")\n            service.force_restart()\n        ```\n    \"\"\"\n    output = subprocess.check_output(\n        [\"tasklist\", \"/FI\", f\"IMAGENAME eq {self.executable_path.name}\"], shell=True, encoding=\"utf-8\"\n    )\n    processes = [line.split()[0] for line in output.splitlines()[2:]]\n    return len(processes) &gt; 0\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.force_restart","title":"force_restart","text":"<pre><code>force_restart(kill_if_running: bool = True) -&gt; Popen[bytes]\n</code></pre> <p>Attempts to restart the Watchdog application.</p> <p>Terminates the existing service if running and starts a new instance with the current configuration.</p> <p>Parameters:</p> Name Type Description Default <code>kill_if_running</code> <code>bool</code> <p>Whether to terminate the service if it's already running</p> <code>True</code> <p>Returns:</p> Type Description <code>Popen[bytes]</code> <p>A subprocess.Popen object representing the restarted service</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def force_restart(self, kill_if_running: bool = True) -&gt; subprocess.Popen[bytes]:\n    \"\"\"\n    Attempts to restart the Watchdog application.\n\n    Terminates the existing service if running and starts a new instance\n    with the current configuration.\n\n    Args:\n        kill_if_running: Whether to terminate the service if it's already running\n\n    Returns:\n        A subprocess.Popen object representing the restarted service\n    \"\"\"\n    if kill_if_running is True:\n        while self.is_running():\n            subprocess.run([\"taskkill\", \"/IM\", self.executable_path.name, \"/F\"], shell=True, check=True)\n\n    cmd_factory = \"{exe} -c {config}\".format(exe=self.executable_path, config=self.config_path)\n\n    return subprocess.Popen(cmd_factory, start_new_session=True, shell=True)\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.dump_manifest_config","title":"dump_manifest_config","text":"<pre><code>dump_manifest_config(\n    path: Optional[PathLike] = None, make_dir: bool = True\n) -&gt; Path\n</code></pre> <p>Dumps the manifest configuration to a YAML file.</p> <p>Saves the current manifest configuration to a file that can be processed by the watchdog service.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Optional[PathLike]</code> <p>The file path to save the manifest</p> <code>None</code> <code>make_dir</code> <code>bool</code> <p>Whether to create the directory if it doesn't exist</p> <code>True</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the saved manifest file</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the manifest or watch configuration is not set</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def dump_manifest_config(self, path: Optional[os.PathLike] = None, make_dir: bool = True) -&gt; Path:\n    \"\"\"\n    Dumps the manifest configuration to a YAML file.\n\n    Saves the current manifest configuration to a file that can be\n    processed by the watchdog service.\n\n    Args:\n        path: The file path to save the manifest\n        make_dir: Whether to create the directory if it doesn't exist\n\n    Returns:\n        The path to the saved manifest file\n\n    Raises:\n        ValueError: If the manifest or watch configuration is not set\n    \"\"\"\n    manifest_config = self._manifest_config\n    watch_config = self._watch_config\n\n    if manifest_config is None or watch_config is None:\n        raise ValueError(\"ManifestConfig or WatchConfig config is not set.\")\n\n    path = (Path(path) if path else Path(watch_config.flag_dir) / f\"manifest_{manifest_config.name}.yaml\").resolve()\n\n    if path.suffix not in [\".yml\", \".yaml\"]:\n        path = path.with_suffix(\".yaml\")\n\n    if not path.name.startswith(\"manifest_\"):\n        logger.debug(\"Prefix manifest_ not found in file name. Appending it.\")\n        path = path.with_name(f\"manifest_{path.stem}{path.suffix}\")\n\n    if make_dir and not path.parent.exists():\n        path.parent.mkdir(parents=True, exist_ok=True)\n\n    manifest_config.destination = Path(manifest_config.destination)\n    manifest_config.schemas = [Path(schema) for schema in manifest_config.schemas]\n    for modality in manifest_config.modalities:\n        manifest_config.modalities[modality] = [_path for _path in manifest_config.modalities[modality]]\n\n    self._write_yaml(manifest_config, path)\n    return path\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.prompt_input","title":"prompt_input","text":"<pre><code>prompt_input() -&gt; bool\n</code></pre> <p>Prompts the user to confirm whether to generate a manifest.</p> <p>Provides user interaction to confirm manifest generation for the watchdog service.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the user confirms, False otherwise</p> Example <pre><code># Interactive manifest generation:\nsettings = WatchdogSettings(\n    destination=\"//server/data\",\n    project_name=\"my_project\"\n)\nservice = WatchdogDataTransferService(source=\"C:/data\", settings=settings)\nif service.prompt_input():\n    service.transfer()\n    print(\"Manifest generation confirmed\")\nelse:\n    print(\"Manifest generation cancelled\")\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>def prompt_input(self) -&gt; bool:\n    \"\"\"\n    Prompts the user to confirm whether to generate a manifest.\n\n    Provides user interaction to confirm manifest generation for the\n    watchdog service.\n\n    Returns:\n        True if the user confirms, False otherwise\n\n    Example:\n        ```python\n        # Interactive manifest generation:\n        settings = WatchdogSettings(\n            destination=\"//server/data\",\n            project_name=\"my_project\"\n        )\n        service = WatchdogDataTransferService(source=\"C:/data\", settings=settings)\n        if service.prompt_input():\n            service.transfer()\n            print(\"Manifest generation confirmed\")\n        else:\n            print(\"Manifest generation cancelled\")\n        ```\n    \"\"\"\n    return self._ui_helper.prompt_yes_no_question(\"Would you like to generate a watchdog manifest (Y/N)?\")\n</code></pre>"},{"location":"api/data_transfer/aind_watchdog/#clabe.data_transfer.aind_watchdog.WatchdogDataTransferService.build_runner","title":"build_runner  <code>classmethod</code>","text":"<pre><code>build_runner(\n    settings: WatchdogSettings,\n    aind_session_data_mapper: Callable[\n        [Launcher[TRig, TSession, TTaskLogic]],\n        TSessionMapper,\n    ]\n    | TSessionMapper,\n    **kwargs,\n) -&gt; Callable[\n    [Launcher[TRig, TSession, TTaskLogic]],\n    WatchdogDataTransferService[TSessionMapper],\n]\n</code></pre> <p>A factory method for creating the watchdog service.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>WatchdogSettings</code> <p>The watchdog settings.</p> required <code>aind_session_data_mapper</code> <code>Callable[[Launcher[TRig, TSession, TTaskLogic]], TSessionMapper] | TSessionMapper</code> <p>The aind session data mapper.</p> required <p>Returns:</p> Type Description <code>Callable[[Launcher[TRig, TSession, TTaskLogic]], WatchdogDataTransferService[TSessionMapper]]</code> <p>A factory for WatchdogDataTransferService.</p> Source code in <code>src\\clabe\\data_transfer\\aind_watchdog.py</code> <pre><code>@classmethod\ndef build_runner(\n    cls,\n    settings: WatchdogSettings,\n    aind_session_data_mapper: Callable[[\"Launcher[TRig, TSession, TTaskLogic]\"], TSessionMapper] | TSessionMapper,\n    **kwargs,\n) -&gt; Callable[[\"Launcher[TRig, TSession, TTaskLogic]\"], \"WatchdogDataTransferService[TSessionMapper]\"]:\n    \"\"\"\n    A factory method for creating the watchdog service.\n\n    Args:\n        settings: The watchdog settings.\n        aind_session_data_mapper: The aind session data mapper.\n\n    Returns:\n        A factory for WatchdogDataTransferService.\n    \"\"\"\n\n    def _from_launcher(\n        launcher: \"Launcher[TRig, TSession, TTaskLogic]\",\n    ) -&gt; \"WatchdogDataTransferService\":\n        \"\"\"Inner callable to create the service from a launcher\"\"\"\n        _aind_session_data_mapper = (\n            aind_session_data_mapper(launcher) if callable(aind_session_data_mapper) else aind_session_data_mapper\n        )\n\n        if not _aind_session_data_mapper.is_mapped():\n            raise ValueError(\"Data mapper has not mapped yet. Cannot create watchdog.\")\n\n        _settings = settings.model_copy()\n\n        _session = launcher.get_session(strict=True)\n        _settings.destination = Path(_settings.destination) / _session.subject\n        service = WatchdogDataTransferService[TSessionMapper](\n            source=launcher.session_directory, settings=_settings, session_name=_session.session_name, **kwargs\n        ).with_aind_session_data_mapper(_aind_session_data_mapper)\n        service.transfer()\n        return service\n\n    return _from_launcher\n</code></pre>"},{"location":"api/data_transfer/data_transfer/","title":"data_transfer","text":""},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.DataTransfer","title":"DataTransfer","text":"<p>               Bases: <code>Service</code>, <code>ABC</code>, <code>Generic[TSettings]</code></p> <p>Abstract base class for data transfer services. All data transfer implementations must inherit from this class and implement its abstract methods.</p> <p>This class defines the interface that all data transfer services must implement, providing a consistent API for different transfer mechanisms such as file copying, cloud uploads, or network transfers.</p> Example <pre><code># Implementing a custom data transfer service with settings:\nclass MyTransferSettings(ServiceSettings):\n    destination: str\n\nclass MyTransferService(DataTransfer[MyTransferSettings]):\n    def __init__(self, source: str, settings: MyTransferSettings):\n        self.source = source\n        self._settings = settings\n\n    def transfer(self) -&gt; None:\n        # Implementation specific transfer logic\n        print(f\"Transferring from {self.source} to {self._settings.destination}\")\n\n    def validate(self) -&gt; bool:\n        # Implementation specific validation\n        return Path(self.source).exists()\n\n# Using the custom service:\nsettings = MyTransferSettings(destination=\"D:/backup\")\nservice = MyTransferService(\"C:/data\", settings)\nif service.validate():\n    service.transfer()\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.DataTransfer.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: TSettings\n</code></pre> <p>Returns the settings for the data transfer service.</p>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.DataTransfer.transfer","title":"transfer  <code>abstractmethod</code>","text":"<pre><code>transfer() -&gt; None\n</code></pre> <p>Executes the data transfer process. Must be implemented by subclasses.</p> <p>This method should contain the core logic for transferring data from source to destination according to the service's specific implementation.</p> Source code in <code>src\\clabe\\data_transfer\\_base.py</code> <pre><code>@abc.abstractmethod\ndef transfer(self) -&gt; None:\n    \"\"\"\n    Executes the data transfer process. Must be implemented by subclasses.\n\n    This method should contain the core logic for transferring data from\n    source to destination according to the service's specific implementation.\n    \"\"\"\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.DataTransfer.validate","title":"validate  <code>abstractmethod</code>","text":"<pre><code>validate() -&gt; bool\n</code></pre> <p>Validates the data transfer service. Must be implemented by subclasses.</p> <p>This method should verify that the service is properly configured and ready to perform data transfers, checking for required dependencies, connectivity, permissions, etc.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the service is valid and ready for use, False otherwise</p> Source code in <code>src\\clabe\\data_transfer\\_base.py</code> <pre><code>@abc.abstractmethod\ndef validate(self) -&gt; bool:\n    \"\"\"\n    Validates the data transfer service. Must be implemented by subclasses.\n\n    This method should verify that the service is properly configured and\n    ready to perform data transfers, checking for required dependencies,\n    connectivity, permissions, etc.\n\n    Returns:\n        True if the service is valid and ready for use, False otherwise\n    \"\"\"\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.RobocopyService","title":"RobocopyService","text":"<pre><code>RobocopyService(\n    source: PathLike,\n    settings: RobocopySettings,\n    *,\n    ui_helper: Optional[UiHelper] = None,\n)\n</code></pre> <p>               Bases: <code>DataTransfer[RobocopySettings]</code></p> <p>A data transfer service that uses the Robocopy command-line utility to copy files between source and destination directories.</p> <p>This service provides a wrapper around the Windows Robocopy utility with configurable options for file copying, logging, and directory management.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>PathLike</code> <p>Source directory or file path</p> <code>_settings</code> <code>RobocopySettings</code> <p>Service settings containing destination, options, etc.</p> <code>_ui_helper</code> <code>UiHelper</code> <p>UI helper for user prompts</p> Example <pre><code># Basic file copying:\nsettings = RobocopySettings(destination=\"D:/backup/experiment1\")\nservice = RobocopyService(\n    source=\"C:/data/experiment1\",\n    settings=settings\n)\nservice.transfer()\n\n# Copy with custom options:\nsettings = RobocopySettings(\n    destination=\"D:/backup/experiment1\",\n    delete_src=True,\n    overwrite=True,\n    log=\"copy_log.txt\",\n    extra_args=\"/E /DCOPY:DAT /R:50 /W:5\"\n)\nservice = RobocopyService(\n    source=\"C:/data/experiment1\",\n    settings=settings\n)\nif service.validate():\n    service.transfer()\n</code></pre> <p>Initializes the RobocopyService.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>PathLike</code> <p>The source directory or file to copy</p> required <code>settings</code> <code>RobocopySettings</code> <p>RobocopySettings containing destination and options</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>UI helper for user prompts. Default is None</p> <code>None</code> Example <pre><code># Initialize with basic parameters:\nsettings = RobocopySettings(destination=\"D:/destination\")\nservice = RobocopyService(\"C:/source\", settings)\n\n# Initialize with logging and move operation:\nsettings = RobocopySettings(\n    destination=\"D:/archive/data\",\n    log=\"transfer.log\",\n    delete_src=True,\n    extra_args=\"/E /COPY:DAT /R:10\"\n)\nservice = RobocopyService(\"C:/temp/data\", settings)\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def __init__(\n    self,\n    source: PathLike,\n    settings: RobocopySettings,\n    *,\n    ui_helper: Optional[ui.UiHelper] = None,\n):\n    \"\"\"\n    Initializes the RobocopyService.\n\n    Args:\n        source: The source directory or file to copy\n        settings: RobocopySettings containing destination and options\n        ui_helper: UI helper for user prompts. Default is None\n\n    Example:\n        ```python\n        # Initialize with basic parameters:\n        settings = RobocopySettings(destination=\"D:/destination\")\n        service = RobocopyService(\"C:/source\", settings)\n\n        # Initialize with logging and move operation:\n        settings = RobocopySettings(\n            destination=\"D:/archive/data\",\n            log=\"transfer.log\",\n            delete_src=True,\n            extra_args=\"/E /COPY:DAT /R:10\"\n        )\n        service = RobocopyService(\"C:/temp/data\", settings)\n        ```\n    \"\"\"\n\n    self.source = source\n    self._settings = settings\n    self._ui_helper = ui_helper or ui.DefaultUIHelper()\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.RobocopyService.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: TSettings\n</code></pre> <p>Returns the settings for the data transfer service.</p>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.RobocopyService.transfer","title":"transfer","text":"<pre><code>transfer() -&gt; None\n</code></pre> <p>Executes the data transfer using Robocopy.</p> <p>Processes source-destination mappings and executes Robocopy commands for each pair, handling logging and error reporting.</p> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def transfer(\n    self,\n) -&gt; None:\n    \"\"\"\n    Executes the data transfer using Robocopy.\n\n    Processes source-destination mappings and executes Robocopy commands\n    for each pair, handling logging and error reporting.\n    \"\"\"\n\n    # Loop through each source-destination pair and call robocopy'\n    logger.info(\"Starting robocopy transfer service.\")\n    src_dist = self._solve_src_dst_mapping(self.source, self._settings.destination)\n    if src_dist is None:\n        raise ValueError(\"Source and destination should be provided.\")\n\n    for src, dst in src_dist.items():\n        dst = Path(dst)\n        src = Path(src)\n        try:\n            command = [\"robocopy\", f\"{src.as_posix()}\", f\"{dst.as_posix()}\", self._settings.extra_args]\n            if self._settings.log:\n                command.append(f'/LOG:\"{Path(dst) / self._settings.log}\"')\n            if self._settings.delete_src:\n                command.append(\"/MOV\")\n            if self._settings.overwrite:\n                command.append(\"/IS\")\n            if self._settings.force_dir:\n                makedirs(dst, exist_ok=True)\n            cmd = \" \".join(command)\n            logger.info(\"Running Robocopy command: %s\", cmd)\n            with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True) as process:\n                if process.stdout:\n                    for line in process.stdout:\n                        logger.info(line.strip())\n            _ = process.wait()\n            logger.info(\"Successfully copied from %s to %s:\\n\", src, dst)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"Error copying from %s to %s:\\n%s\", src, dst, e.stdout)\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.RobocopyService.validate","title":"validate","text":"<pre><code>validate() -&gt; bool\n</code></pre> <p>Validates whether the Robocopy command is available on the system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if Robocopy is available, False otherwise</p> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"\n    Validates whether the Robocopy command is available on the system.\n\n    Returns:\n        True if Robocopy is available, False otherwise\n    \"\"\"\n    if not _HAS_ROBOCOPY:\n        logger.warning(\"Robocopy command is not available on this system.\")\n        return False\n    return True\n</code></pre>"},{"location":"api/data_transfer/data_transfer/#clabe.data_transfer.RobocopyService.prompt_input","title":"prompt_input","text":"<pre><code>prompt_input() -&gt; bool\n</code></pre> <p>Prompts the user to confirm whether to trigger the Robocopy transfer.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the user confirms, False otherwise</p> Example <pre><code># Interactive transfer confirmation:\nsettings = RobocopySettings(destination=\"D:/backup\")\nservice = RobocopyService(\"C:/data\", settings)\nif service.prompt_input():\n    service.transfer()\n    # User confirmed, transfer proceeds\nelse:\n    print(\"Transfer cancelled by user\")\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def prompt_input(self) -&gt; bool:\n    \"\"\"\n    Prompts the user to confirm whether to trigger the Robocopy transfer.\n\n    Returns:\n        True if the user confirms, False otherwise\n\n    Example:\n        ```python\n        # Interactive transfer confirmation:\n        settings = RobocopySettings(destination=\"D:/backup\")\n        service = RobocopyService(\"C:/data\", settings)\n        if service.prompt_input():\n            service.transfer()\n            # User confirmed, transfer proceeds\n        else:\n            print(\"Transfer cancelled by user\")\n        ```\n    \"\"\"\n    return self._ui_helper.prompt_yes_no_question(\"Would you like to trigger robocopy (Y/N)?\")\n</code></pre>"},{"location":"api/data_transfer/robocopy/","title":"data_transfer.robocopy","text":""},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopySettings","title":"RobocopySettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the RobocopyService.</p> <p>Attributes:</p> Name Type Description <code>destination</code> <code>PathLike</code> <p>The destination path for the data transfer.</p> <code>log</code> <code>Optional[PathLike]</code> <p>The path to the log file.</p> <code>extra_args</code> <code>str</code> <p>Extra arguments to pass to Robocopy.</p> <code>delete_src</code> <code>bool</code> <p>Whether to delete the source files after copying.</p> <code>overwrite</code> <code>bool</code> <p>Whether to overwrite existing files.</p> <code>force_dir</code> <code>bool</code> <p>Whether to create the destination directory if it does not exist.</p>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopySettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopyService","title":"RobocopyService","text":"<pre><code>RobocopyService(\n    source: PathLike,\n    settings: RobocopySettings,\n    *,\n    ui_helper: Optional[UiHelper] = None,\n)\n</code></pre> <p>               Bases: <code>DataTransfer[RobocopySettings]</code></p> <p>A data transfer service that uses the Robocopy command-line utility to copy files between source and destination directories.</p> <p>This service provides a wrapper around the Windows Robocopy utility with configurable options for file copying, logging, and directory management.</p> <p>Attributes:</p> Name Type Description <code>source</code> <code>PathLike</code> <p>Source directory or file path</p> <code>_settings</code> <code>RobocopySettings</code> <p>Service settings containing destination, options, etc.</p> <code>_ui_helper</code> <code>UiHelper</code> <p>UI helper for user prompts</p> Example <pre><code># Basic file copying:\nsettings = RobocopySettings(destination=\"D:/backup/experiment1\")\nservice = RobocopyService(\n    source=\"C:/data/experiment1\",\n    settings=settings\n)\nservice.transfer()\n\n# Copy with custom options:\nsettings = RobocopySettings(\n    destination=\"D:/backup/experiment1\",\n    delete_src=True,\n    overwrite=True,\n    log=\"copy_log.txt\",\n    extra_args=\"/E /DCOPY:DAT /R:50 /W:5\"\n)\nservice = RobocopyService(\n    source=\"C:/data/experiment1\",\n    settings=settings\n)\nif service.validate():\n    service.transfer()\n</code></pre> <p>Initializes the RobocopyService.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>PathLike</code> <p>The source directory or file to copy</p> required <code>settings</code> <code>RobocopySettings</code> <p>RobocopySettings containing destination and options</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>UI helper for user prompts. Default is None</p> <code>None</code> Example <pre><code># Initialize with basic parameters:\nsettings = RobocopySettings(destination=\"D:/destination\")\nservice = RobocopyService(\"C:/source\", settings)\n\n# Initialize with logging and move operation:\nsettings = RobocopySettings(\n    destination=\"D:/archive/data\",\n    log=\"transfer.log\",\n    delete_src=True,\n    extra_args=\"/E /COPY:DAT /R:10\"\n)\nservice = RobocopyService(\"C:/temp/data\", settings)\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def __init__(\n    self,\n    source: PathLike,\n    settings: RobocopySettings,\n    *,\n    ui_helper: Optional[ui.UiHelper] = None,\n):\n    \"\"\"\n    Initializes the RobocopyService.\n\n    Args:\n        source: The source directory or file to copy\n        settings: RobocopySettings containing destination and options\n        ui_helper: UI helper for user prompts. Default is None\n\n    Example:\n        ```python\n        # Initialize with basic parameters:\n        settings = RobocopySettings(destination=\"D:/destination\")\n        service = RobocopyService(\"C:/source\", settings)\n\n        # Initialize with logging and move operation:\n        settings = RobocopySettings(\n            destination=\"D:/archive/data\",\n            log=\"transfer.log\",\n            delete_src=True,\n            extra_args=\"/E /COPY:DAT /R:10\"\n        )\n        service = RobocopyService(\"C:/temp/data\", settings)\n        ```\n    \"\"\"\n\n    self.source = source\n    self._settings = settings\n    self._ui_helper = ui_helper or ui.DefaultUIHelper()\n</code></pre>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopyService.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: TSettings\n</code></pre> <p>Returns the settings for the data transfer service.</p>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopyService.transfer","title":"transfer","text":"<pre><code>transfer() -&gt; None\n</code></pre> <p>Executes the data transfer using Robocopy.</p> <p>Processes source-destination mappings and executes Robocopy commands for each pair, handling logging and error reporting.</p> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def transfer(\n    self,\n) -&gt; None:\n    \"\"\"\n    Executes the data transfer using Robocopy.\n\n    Processes source-destination mappings and executes Robocopy commands\n    for each pair, handling logging and error reporting.\n    \"\"\"\n\n    # Loop through each source-destination pair and call robocopy'\n    logger.info(\"Starting robocopy transfer service.\")\n    src_dist = self._solve_src_dst_mapping(self.source, self._settings.destination)\n    if src_dist is None:\n        raise ValueError(\"Source and destination should be provided.\")\n\n    for src, dst in src_dist.items():\n        dst = Path(dst)\n        src = Path(src)\n        try:\n            command = [\"robocopy\", f\"{src.as_posix()}\", f\"{dst.as_posix()}\", self._settings.extra_args]\n            if self._settings.log:\n                command.append(f'/LOG:\"{Path(dst) / self._settings.log}\"')\n            if self._settings.delete_src:\n                command.append(\"/MOV\")\n            if self._settings.overwrite:\n                command.append(\"/IS\")\n            if self._settings.force_dir:\n                makedirs(dst, exist_ok=True)\n            cmd = \" \".join(command)\n            logger.info(\"Running Robocopy command: %s\", cmd)\n            with subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True) as process:\n                if process.stdout:\n                    for line in process.stdout:\n                        logger.info(line.strip())\n            _ = process.wait()\n            logger.info(\"Successfully copied from %s to %s:\\n\", src, dst)\n        except subprocess.CalledProcessError as e:\n            logger.error(\"Error copying from %s to %s:\\n%s\", src, dst, e.stdout)\n</code></pre>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopyService.validate","title":"validate","text":"<pre><code>validate() -&gt; bool\n</code></pre> <p>Validates whether the Robocopy command is available on the system.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if Robocopy is available, False otherwise</p> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def validate(self) -&gt; bool:\n    \"\"\"\n    Validates whether the Robocopy command is available on the system.\n\n    Returns:\n        True if Robocopy is available, False otherwise\n    \"\"\"\n    if not _HAS_ROBOCOPY:\n        logger.warning(\"Robocopy command is not available on this system.\")\n        return False\n    return True\n</code></pre>"},{"location":"api/data_transfer/robocopy/#clabe.data_transfer.robocopy.RobocopyService.prompt_input","title":"prompt_input","text":"<pre><code>prompt_input() -&gt; bool\n</code></pre> <p>Prompts the user to confirm whether to trigger the Robocopy transfer.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the user confirms, False otherwise</p> Example <pre><code># Interactive transfer confirmation:\nsettings = RobocopySettings(destination=\"D:/backup\")\nservice = RobocopyService(\"C:/data\", settings)\nif service.prompt_input():\n    service.transfer()\n    # User confirmed, transfer proceeds\nelse:\n    print(\"Transfer cancelled by user\")\n</code></pre> Source code in <code>src\\clabe\\data_transfer\\robocopy.py</code> <pre><code>def prompt_input(self) -&gt; bool:\n    \"\"\"\n    Prompts the user to confirm whether to trigger the Robocopy transfer.\n\n    Returns:\n        True if the user confirms, False otherwise\n\n    Example:\n        ```python\n        # Interactive transfer confirmation:\n        settings = RobocopySettings(destination=\"D:/backup\")\n        service = RobocopyService(\"C:/data\", settings)\n        if service.prompt_input():\n            service.transfer()\n            # User confirmed, transfer proceeds\n        else:\n            print(\"Transfer cancelled by user\")\n        ```\n    \"\"\"\n    return self._ui_helper.prompt_yes_no_question(\"Would you like to trigger robocopy (Y/N)?\")\n</code></pre>"},{"location":"api/git_manager/git_manager/","title":"git_manager","text":""},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository","title":"GitRepository","text":"<pre><code>GitRepository(*args, **kwargs)\n</code></pre> <p>               Bases: <code>Repo</code></p> <p>A wrapper around the <code>git.Repo</code> class that provides additional methods for managing Git repositories and their submodules.</p> <p>This class extends the functionality of GitPython's Repo class with additional utilities for repository management, submodule handling, and cleanup operations.</p> <p>Initializes the GitRepository instance and validates the presence of Git.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Arguments passed to the parent Repo class</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed to the parent Repo class</p> <code>{}</code> Example <pre><code># Initialize with current directory\nrepo = GitRepository()\n\n# Initialize with specific path\nrepo = GitRepository(path=\"/path/to/repo\")\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Initializes the GitRepository instance and validates the presence of Git.\n\n    Args:\n        *args: Arguments passed to the parent Repo class\n        **kwargs: Keyword arguments passed to the parent Repo class\n\n    Example:\n        ```python\n        # Initialize with current directory\n        repo = GitRepository()\n\n        # Initialize with specific path\n        repo = GitRepository(path=\"/path/to/repo\")\n        ```\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    self._validate_git()\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.reset_repo","title":"reset_repo","text":"<pre><code>reset_repo() -&gt; Self\n</code></pre> <p>Resets the repository to the last committed state.</p> <p>Performs a hard reset to discard all uncommitted changes in the working directory and staging area, reverting to the last commit.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nrepo.reset_repo()  # Discards all uncommitted changes\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def reset_repo(self) -&gt; Self:\n    \"\"\"\n    Resets the repository to the last committed state.\n\n    Performs a hard reset to discard all uncommitted changes in the working directory\n    and staging area, reverting to the last commit.\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        repo.reset_repo()  # Discards all uncommitted changes\n        ```\n    \"\"\"\n    self.git.reset(\"--hard\")\n    return self\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.clean_repo","title":"clean_repo","text":"<pre><code>clean_repo() -&gt; Self\n</code></pre> <p>Cleans the repository by removing untracked files and directories.</p> <p>Removes all untracked files and directories from the working tree that are not ignored by .gitignore rules.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nrepo.clean_repo()  # Removes all untracked files and directories\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def clean_repo(self) -&gt; Self:\n    \"\"\"\n    Cleans the repository by removing untracked files and directories.\n\n    Removes all untracked files and directories from the working tree that are\n    not ignored by .gitignore rules.\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        repo.clean_repo()  # Removes all untracked files and directories\n        ```\n    \"\"\"\n    self.git.clean(\"-fd\")\n    return self\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.is_dirty_with_submodules","title":"is_dirty_with_submodules","text":"<pre><code>is_dirty_with_submodules() -&gt; bool\n</code></pre> <p>Checks if the repository or any of its submodules is dirty.</p> <p>A repository is considered dirty if it has uncommitted changes, including untracked files. This method also checks all submodules.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the repository or any submodules have uncommitted changes.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nif repo.is_dirty_with_submodules():\n    print(\"Repository or submodules have uncommitted changes\")\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def is_dirty_with_submodules(self) -&gt; bool:\n    \"\"\"\n    Checks if the repository or any of its submodules is dirty.\n\n    A repository is considered dirty if it has uncommitted changes, including\n    untracked files. This method also checks all submodules.\n\n    Returns:\n        bool: True if the repository or any submodules have uncommitted changes.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        if repo.is_dirty_with_submodules():\n            print(\"Repository or submodules have uncommitted changes\")\n        ```\n    \"\"\"\n    _is_dirty_repo = self.is_dirty(untracked_files=True)\n    if _is_dirty_repo:\n        return True\n    return any([submodule.repo.is_dirty(untracked_files=True) for submodule in self.submodules])\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.uncommitted_changes","title":"uncommitted_changes","text":"<pre><code>uncommitted_changes() -&gt; List[str]\n</code></pre> <p>Retrieves a list of unstaged and untracked files in the repository and its submodules.</p> <p>Combines modified files, staged changes, and untracked files from both the main repository and all submodules.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of file paths with uncommitted changes.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nchanges = repo.uncommitted_changes()\nif changes:\n    print(f\"Uncommitted changes found: {changes}\")\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def uncommitted_changes(self) -&gt; List[str]:\n    \"\"\"\n    Retrieves a list of unstaged and untracked files in the repository and its submodules.\n\n    Combines modified files, staged changes, and untracked files from both the main\n    repository and all submodules.\n\n    Returns:\n        List[str]: A list of file paths with uncommitted changes.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        changes = repo.uncommitted_changes()\n        if changes:\n            print(f\"Uncommitted changes found: {changes}\")\n        ```\n    \"\"\"\n    untracked_files = self.untracked_files\n    changes = self._get_changes(self)\n    for submodule in self.submodules:\n        changes.extend(self._get_changes(submodule.repo))\n        untracked_files.extend(submodule.repo.untracked_files)\n    return list(set(changes + untracked_files))\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.force_update_submodules","title":"force_update_submodules","text":"<pre><code>force_update_submodules() -&gt; Self\n</code></pre> <p>Updates all submodules to their latest state.</p> <p>Forces an update of all Git submodules to match the commit specified in the parent repository.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nrepo.force_update_submodules()  # Updates all submodules\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def force_update_submodules(self) -&gt; Self:\n    \"\"\"\n    Updates all submodules to their latest state.\n\n    Forces an update of all Git submodules to match the commit specified\n    in the parent repository.\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        repo.force_update_submodules()  # Updates all submodules\n        ```\n    \"\"\"\n    self.submodule_update()\n    return self\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.submodules_sync","title":"submodules_sync","text":"<pre><code>submodules_sync() -&gt; Self\n</code></pre> <p>Synchronizes submodule URLs with the parent repository.</p> <p>Updates the submodule URLs to match those defined in the parent repository's .gitmodules file.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nrepo.submodules_sync()  # Synchronizes submodule URLs\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def submodules_sync(self) -&gt; Self:\n    \"\"\"\n    Synchronizes submodule URLs with the parent repository.\n\n    Updates the submodule URLs to match those defined in the parent repository's\n    .gitmodules file.\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        repo.submodules_sync()  # Synchronizes submodule URLs\n        ```\n    \"\"\"\n    self.git.submodule(\"sync\", \"--recursive\")\n    return self\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.full_reset","title":"full_reset","text":"<pre><code>full_reset() -&gt; Self\n</code></pre> <p>Performs a full reset of the repository and its submodules.</p> <p>Executes a complete cleanup including resetting the repository, synchronizing submodules, updating them, and cleaning untracked files. Also recursively resets all submodules.</p> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nrepo.full_reset()  # Complete cleanup of repo and submodules\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def full_reset(self) -&gt; Self:\n    \"\"\"\n    Performs a full reset of the repository and its submodules.\n\n    Executes a complete cleanup including resetting the repository, synchronizing\n    submodules, updating them, and cleaning untracked files. Also recursively\n    resets all submodules.\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        repo.full_reset()  # Complete cleanup of repo and submodules\n        ```\n    \"\"\"\n    self.reset_repo().submodules_sync().force_update_submodules().clean_repo()\n    _ = [GitRepository(str(sub.abspath)).full_reset() for sub in self.submodules]\n    return self\n</code></pre>"},{"location":"api/git_manager/git_manager/#clabe.git_manager.GitRepository.try_prompt_full_reset","title":"try_prompt_full_reset","text":"<pre><code>try_prompt_full_reset(\n    ui_helper: UiHelper, force_reset: bool = False\n) -&gt; Self\n</code></pre> <p>Prompts the user to perform a full reset if the repository is dirty.</p> <p>Checks if the repository has uncommitted changes and either prompts the user or automatically performs a full reset based on the force_reset parameter.</p> <p>Parameters:</p> Name Type Description Default <code>ui_helper</code> <code>UiHelper</code> <p>The UI helper for user interaction</p> required <code>force_reset</code> <code>bool</code> <p>Whether to skip the prompt and force a reset</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The current instance for method chaining.</p> Example <pre><code>repo = GitRepository(\"/path/to/repo\")\nui_helper = ui.DefaultUIHelper()\nrepo.try_prompt_full_reset(ui_helper)  # Prompts user if dirty\nrepo.try_prompt_full_reset(ui_helper, force_reset=True)  # Forces reset\n</code></pre> Source code in <code>src\\clabe\\git_manager\\_git.py</code> <pre><code>def try_prompt_full_reset(self, ui_helper: ui.UiHelper, force_reset: bool = False) -&gt; Self:\n    \"\"\"\n    Prompts the user to perform a full reset if the repository is dirty.\n\n    Checks if the repository has uncommitted changes and either prompts the user\n    or automatically performs a full reset based on the force_reset parameter.\n\n    Args:\n        ui_helper: The UI helper for user interaction\n        force_reset: Whether to skip the prompt and force a reset\n\n    Returns:\n        Self: The current instance for method chaining.\n\n    Example:\n        ```python\n        repo = GitRepository(\"/path/to/repo\")\n        ui_helper = ui.DefaultUIHelper()\n        repo.try_prompt_full_reset(ui_helper)  # Prompts user if dirty\n        repo.try_prompt_full_reset(ui_helper, force_reset=True)  # Forces reset\n        ```\n    \"\"\"\n    if force_reset:\n        self.full_reset()\n        return self\n    if self.is_dirty_with_submodules():\n        logger.info(\"Repository is dirty! %s\", self.working_dir)\n        logger.info(\"Uncommitted files: %s\", self.uncommitted_changes())\n        if not force_reset:\n            is_reset = ui_helper.prompt_yes_no_question(prompt=\"Do you want to reset the repository?\")\n        else:\n            is_reset = True\n        if is_reset:\n            logger.info(\"Full reset of repository and submodules: %s\", self.working_dir)\n            self.full_reset()\n    return self\n</code></pre>"},{"location":"api/launcher/launcher/","title":"launcher","text":""},{"location":"api/launcher/launcher/#clabe.launcher.Launcher","title":"Launcher","text":"<pre><code>Launcher(\n    *,\n    settings: LauncherCliArgs,\n    rig: TRig | Type[TRig],\n    session: TSession | Type[TSession],\n    task_logic: TTaskLogic | Type[TTaskLogic],\n    attached_logger: Optional[Logger] = None,\n    ui_helper: UiHelper = DefaultUIHelper(),\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>Generic[TRig, TSession, TTaskLogic]</code></p> <p>Abstract base class for experiment launchers. Provides common functionality for managing configuration files, directories, and registered callables.</p> <p>This class serves as the foundation for all launcher implementations, providing schema management, directory handling, validation, and lifecycle management.</p> <p>          Class Type Parameters:        </p> Name Bound or Constraints Description Default <code>TRig</code> <p>Type of the rig schema model</p> required <code>TSession</code> <p>Type of the session schema model</p> required <code>TTaskLogic</code> <p>Type of the task logic schema model</p> required <p>Initializes the Launcher instance.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>LauncherCliArgs</code> <p>The settings for the launcher</p> required <code>rig</code> <code>TRig | Type[TRig]</code> <p>The rig schema model instance or class</p> required <code>session</code> <code>TSession | Type[TSession]</code> <p>The session schema model instance or class</p> required <code>task_logic</code> <code>TTaskLogic | Type[TTaskLogic]</code> <p>The task logic schema model instance or class</p> required <code>attached_logger</code> <code>Optional[Logger]</code> <p>An attached logger instance. Defaults to None</p> <code>None</code> <code>ui_helper</code> <code>UiHelper</code> <p>The UI helper for user interactions. Defaults to DefaultUIHelper</p> <code>DefaultUIHelper()</code> <code>**kwargs</code> <p>Additional keyword arguments</p> <code>{}</code> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def __init__(\n    self,\n    *,\n    settings: LauncherCliArgs,\n    rig: TRig | Type[TRig],\n    session: TSession | Type[TSession],\n    task_logic: TTaskLogic | Type[TTaskLogic],\n    attached_logger: Optional[logging.Logger] = None,\n    ui_helper: UiHelper = DefaultUIHelper(),\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initializes the Launcher instance.\n\n    Args:\n        settings: The settings for the launcher\n        rig: The rig schema model instance or class\n        session: The session schema model instance or class\n        task_logic: The task logic schema model instance or class\n        attached_logger: An attached logger instance. Defaults to None\n        ui_helper: The UI helper for user interactions. Defaults to DefaultUIHelper\n        **kwargs: Additional keyword arguments\n    \"\"\"\n    self._settings = settings\n    self.ui_helper = ui_helper\n    self._on_error_handler: Optional[Callable[[Self, Exception], None]] = None\n    self.temp_dir = abspath(settings.temp_dir) / format_datetime(utcnow())\n    self.temp_dir.mkdir(parents=True, exist_ok=True)\n    self.computer_name = os.environ[\"COMPUTERNAME\"]\n\n    # Solve logger\n    if attached_logger:\n        _logger = logging_helper.add_file_handler(attached_logger, self.temp_dir / \"launcher.log\")\n    else:\n        root_logger = logging.getLogger()\n        _logger = logging_helper.add_file_handler(root_logger, self.temp_dir / \"launcher.log\")\n\n    if settings.debug_mode:\n        _logger.setLevel(logging.DEBUG)\n\n    self._logger = _logger\n\n    # Create callable managers\n    self._callable_manager: _CallableManager[[Self], Any] = _CallableManager()\n\n    repository_dir = Path(self.settings.repository_dir) if self.settings.repository_dir is not None else None\n    self.repository = GitRepository() if repository_dir is None else GitRepository(path=repository_dir)\n    self._cwd = self.repository.working_dir\n    os.chdir(self._cwd)\n\n    # Schemas\n    self._rig, self._rig_model = self._resolve_model(rig)\n    self._session, self._session_model = self._resolve_model(session)\n    self._task_logic, self._task_logic_model = self._resolve_model(task_logic)\n\n    self._ensure_directory_structure()\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.callable_manager","title":"callable_manager  <code>property</code>","text":"<pre><code>callable_manager: _CallableManager[[Self], Any]\n</code></pre> <p>Returns the callable managers for the launcher.</p> <p>Returns:</p> Type Description <code>_CallableManager[[Self], Any]</code> <p>_CallableManager[Self, Any]: The callable managers for the launcher</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.logger","title":"logger  <code>property</code>","text":"<pre><code>logger: Logger\n</code></pre> <p>Returns the logger instance used by the launcher.</p> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The logger instance</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.subject","title":"subject  <code>property</code> <code>writable</code>","text":"<pre><code>subject: Optional[str]\n</code></pre> <p>Returns the current subject name.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The subject name or None if not set</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.settings","title":"settings  <code>property</code>","text":"<pre><code>settings: LauncherCliArgs\n</code></pre> <p>Returns the launcher settings.</p> <p>Returns:</p> Name Type Description <code>LauncherCliArgs</code> <code>LauncherCliArgs</code> <p>The launcher settings</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.session_directory","title":"session_directory  <code>property</code>","text":"<pre><code>session_directory: Path\n</code></pre> <p>Returns the session directory path.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The session directory path</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If session_name is not set in the session schema</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.main","title":"main","text":"<pre><code>main() -&gt; None\n</code></pre> <p>Main entry point for the launcher execution.</p> <p>Orchestrates the complete launcher workflow including validation, UI prompting, callable execution, and cleanup.</p> Example <p>launcher = MyLauncher(...) launcher.main()  # Starts the launcher workflow</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def main(self) -&gt; None:\n    \"\"\"\n    Main entry point for the launcher execution.\n\n    Orchestrates the complete launcher workflow including validation,\n    UI prompting, callable execution, and cleanup.\n\n    Example:\n        launcher = MyLauncher(...)\n        launcher.main()  # Starts the launcher workflow\n    \"\"\"\n    _code = 0\n    try:\n        logger.info(self.make_header())\n        if self.settings.debug_mode:\n            self._print_debug()\n\n        if not self.settings.debug_mode:\n            self.validate()\n\n        try:\n            self.callable_manager.run(self)\n        except Exception as e:\n            if self._on_error_handler:\n                self._on_error_handler(self, e)\n            else:\n                raise\n\n    except KeyboardInterrupt:\n        logger.error(\"User interrupted the process.\")\n        _code = -1\n    except Exception as e:\n        logger.error(\"Launcher failed: %s\", e)\n        _code = -1\n    finally:\n        try:\n            self.copy_logs()\n        except ValueError as ve:  # In the case session_directory fails\n            logger.error(\"Failed to copy logs: %s\", ve)  # we swallow the error\n            self._exit(-1)\n        else:\n            self._exit(_code)\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.register_on_error","title":"register_on_error","text":"<pre><code>register_on_error(\n    handler: Callable[[Self, Exception], None],\n) -&gt; None\n</code></pre> <p>Registers an error handler to be called on exceptions during launcher execution.</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable[[Self, Exception], None]</code> <p>A callable that takes the launcher instance and the exception as arguments</p> required Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def register_on_error(self, handler: Callable[[Self, Exception], None]) -&gt; None:\n    \"\"\"\n    Registers an error handler to be called on exceptions during launcher execution.\n\n    Args:\n        handler: A callable that takes the launcher instance and the exception as arguments\n    \"\"\"\n    self._on_error_handler = handler\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.copy_logs","title":"copy_logs","text":"<pre><code>copy_logs(dst: Optional[PathLike] = None) -&gt; None\n</code></pre> <p>Closes the file handlers of the launcher and copies the temporary data to the session directory.</p> <p>This method is typically called at the end of the launcher by a registered callable that transfers data.</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def copy_logs(self, dst: Optional[os.PathLike] = None) -&gt; None:\n    \"\"\"\n    Closes the file handlers of the launcher and copies the temporary data to the session directory.\n\n    This method is typically called at the end of the launcher by a registered callable that transfers data.\n    \"\"\"\n    logging_helper.close_file_handlers(logger)\n    if dst is not None:\n        self._copy_tmp_directory(dst)\n    else:\n        self._copy_tmp_directory(self.session_directory / \"Behavior\" / \"Logs\")\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.register_callable","title":"register_callable","text":"<pre><code>register_callable(\n    callable: Callable[[Self], _TOutput],\n) -&gt; Promise[[Self], _TOutput]\n</code></pre><pre><code>register_callable(\n    callable: List[Callable[[Self], _TOutput]],\n) -&gt; List[Promise[[Self], _TOutput]]\n</code></pre> <pre><code>register_callable(\n    callable: Callable[[Self], _TOutput]\n    | List[Callable[[Self], _TOutput]],\n) -&gt; Union[\n    Promise[[Self], _TOutput],\n    List[Promise[[Self], _TOutput]],\n]\n</code></pre> <p>Adds a callable to the launcher and returns a promise for its result.</p> <p>Parameters:</p> Name Type Description Default <code>callable</code> <code>Callable[[Self], _TOutput] | List[Callable[[Self], _TOutput]]</code> <p>The callable or list of callables to add to the launcher</p> required <p>Returns:</p> Type Description <code>Union[Promise[[Self], _TOutput], List[Promise[[Self], _TOutput]]]</code> <p>Promise or list of Promises that can be used to access callable results</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def register_callable(\n    self, callable: Callable[[Self], _TOutput] | List[Callable[[Self], _TOutput]]\n) -&gt; Union[Promise[[Self], _TOutput], List[Promise[[Self], _TOutput]]]:\n    \"\"\"\n    Adds a callable to the launcher and returns a promise for its result.\n\n    Args:\n        callable: The callable or list of callables to add to the launcher\n\n    Returns:\n        Promise or list of Promises that can be used to access callable results\n    \"\"\"\n    if isinstance(callable, list):\n        promises = []\n        for h in callable:\n            promise = self._callable_manager.register(h)\n            promises.append(promise)\n        return promises\n    else:\n        promise = self._callable_manager.register(callable)\n        return promise\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_rig","title":"get_rig","text":"<pre><code>get_rig() -&gt; Optional[TRig]\n</code></pre><pre><code>get_rig(strict: Literal[False]) -&gt; Optional[TRig]\n</code></pre><pre><code>get_rig(strict: Literal[True]) -&gt; TRig\n</code></pre> <pre><code>get_rig(strict: bool = False) -&gt; Optional[TRig]\n</code></pre> <p>Returns the rig schema instance.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>If True, raises ValueError if rig schema is not set</p> <code>False</code> <p>Returns:</p> Type Description <code>Optional[TRig]</code> <p>Optional[TRig]: The rig schema instance</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_rig(self, strict: bool = False) -&gt; Optional[TRig]:\n    \"\"\"\n    Returns the rig schema instance.\n\n    Args:\n        strict: If True, raises ValueError if rig schema is not set\n\n    Returns:\n        Optional[TRig]: The rig schema instance\n    \"\"\"\n    if self._rig is None and strict:\n        raise ValueError(\"Rig schema instance is not set.\")\n    return self._rig\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.set_rig","title":"set_rig","text":"<pre><code>set_rig(rig: TRig) -&gt; None\n</code></pre><pre><code>set_rig(rig: TRig, force: Literal[False]) -&gt; None\n</code></pre><pre><code>set_rig(rig: TRig, force: Literal[True]) -&gt; None\n</code></pre> <pre><code>set_rig(rig: TRig, force: bool = False) -&gt; None\n</code></pre> <p>Sets the rig schema instance.</p> <p>Parameters:</p> Name Type Description Default <code>rig</code> <code>TRig</code> <p>The rig schema instance to set.</p> required <code>force</code> <code>bool</code> <p>If True, allows overriding an existing rig. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If rig is already set and force is False</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def set_rig(self, rig: TRig, force: bool = False) -&gt; None:\n    \"\"\"\n    Sets the rig schema instance.\n\n    Args:\n        rig: The rig schema instance to set.\n        force: If True, allows overriding an existing rig. Defaults to False.\n\n    Raises:\n        ValueError: If rig is already set and force is False\n    \"\"\"\n    if self._rig is not None and not force:\n        raise ValueError(\"Rig already set.\")\n    rig = self._rig_model.model_validate_json(rig.model_dump_json())\n    self._rig, self._rig_model = self._resolve_model(rig)\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_rig_model","title":"get_rig_model","text":"<pre><code>get_rig_model() -&gt; Type[TRig]\n</code></pre> <p>Returns the rig schema model class.</p> <p>Returns:</p> Type Description <code>Type[TRig]</code> <p>Type[TRig]: The rig schema model class</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_rig_model(self) -&gt; Type[TRig]:\n    \"\"\"\n    Returns the rig schema model class.\n\n    Returns:\n        Type[TRig]: The rig schema model class\n    \"\"\"\n    return self._rig_model\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_session","title":"get_session","text":"<pre><code>get_session() -&gt; Optional[TSession]\n</code></pre><pre><code>get_session(strict: Literal[False]) -&gt; Optional[TSession]\n</code></pre><pre><code>get_session(strict: Literal[True]) -&gt; TSession\n</code></pre> <pre><code>get_session(strict: bool = False) -&gt; Optional[TSession]\n</code></pre> <p>Returns the session schema instance. Args:     strict: If True, raises ValueError if session schema is not set</p> <p>Returns:</p> Name Type Description <code>TSession</code> <code>Optional[TSession]</code> <p>The session schema instance</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_session(self, strict: bool = False) -&gt; Optional[TSession]:\n    \"\"\"\n    Returns the session schema instance.\n    Args:\n        strict: If True, raises ValueError if session schema is not set\n\n    Returns:\n        TSession: The session schema instance\n    \"\"\"\n    if self._session is None and strict:\n        raise ValueError(\"Session schema instance is not set.\")\n    return self._session\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.set_session","title":"set_session","text":"<pre><code>set_session(session: TSession) -&gt; None\n</code></pre><pre><code>set_session(\n    session: TSession, force: Literal[False]\n) -&gt; None\n</code></pre><pre><code>set_session(\n    session: TSession, force: Literal[True]\n) -&gt; None\n</code></pre> <pre><code>set_session(session: TSession, force: bool = False) -&gt; None\n</code></pre> <p>Sets the session schema instance.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>TSession</code> <p>The session schema instance to set.</p> required <code>force</code> <code>bool</code> <p>If True, allows overriding an existing session. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If session is already set and force is False</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def set_session(self, session: TSession, force: bool = False) -&gt; None:\n    \"\"\"\n    Sets the session schema instance.\n\n    Args:\n        session: The session schema instance to set.\n        force: If True, allows overriding an existing session. Defaults to False.\n\n    Raises:\n        ValueError: If session is already set and force is False\n    \"\"\"\n    if self._session is not None and not force:\n        raise ValueError(\"Session already set.\")\n    self._session = self._session_model.model_validate_json(session.model_dump_json())\n    self._session, self._session_model = self._resolve_model(self._session)\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_session_model","title":"get_session_model","text":"<pre><code>get_session_model() -&gt; Type[TSession]\n</code></pre> <p>Returns the session schema model class.</p> <p>Returns:</p> Type Description <code>Type[TSession]</code> <p>Type[TSession]: The session schema model class</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_session_model(self) -&gt; Type[TSession]:\n    \"\"\"\n    Returns the session schema model class.\n\n    Returns:\n        Type[TSession]: The session schema model class\n    \"\"\"\n    return self._session_model\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_task_logic","title":"get_task_logic","text":"<pre><code>get_task_logic() -&gt; Optional[TTaskLogic]\n</code></pre><pre><code>get_task_logic(\n    strict: Literal[False],\n) -&gt; Optional[TTaskLogic]\n</code></pre><pre><code>get_task_logic(strict: Literal[True]) -&gt; TTaskLogic\n</code></pre> <pre><code>get_task_logic(\n    strict: bool = False,\n) -&gt; Optional[TTaskLogic]\n</code></pre> <p>Returns the task logic schema instance. Args:     strict: If True, raises ValueError if task logic schema is not set Returns:     TTaskLogic: The task logic schema instance</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_task_logic(self, strict: bool = False) -&gt; Optional[TTaskLogic]:\n    \"\"\"\n    Returns the task logic schema instance.\n    Args:\n        strict: If True, raises ValueError if task logic schema is not set\n    Returns:\n        TTaskLogic: The task logic schema instance\n    \"\"\"\n    if self._task_logic is None and strict:\n        raise ValueError(\"Task logic schema instance is not set.\")\n    return self._task_logic\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.set_task_logic","title":"set_task_logic","text":"<pre><code>set_task_logic(task_logic: TTaskLogic) -&gt; None\n</code></pre><pre><code>set_task_logic(\n    task_logic: TTaskLogic, force: Literal[False]\n) -&gt; None\n</code></pre><pre><code>set_task_logic(\n    task_logic: TTaskLogic, force: Literal[True]\n) -&gt; None\n</code></pre> <pre><code>set_task_logic(\n    task_logic: TTaskLogic, force: bool = False\n) -&gt; None\n</code></pre> <p>Sets the task logic schema instance. Before setting the task logic, it validates the input by forcing a round-trip (de)serialization.</p> <p>Parameters:</p> Name Type Description Default <code>task_logic</code> <code>TTaskLogic</code> <p>The task logic schema instance to set.</p> required <code>force</code> <code>bool</code> <p>If True, allows overriding an existing task logic. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If task logic is already set and force is False</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def set_task_logic(self, task_logic: TTaskLogic, force: bool = False) -&gt; None:\n    \"\"\"\n    Sets the task logic schema instance.\n    Before setting the task logic, it validates the input by forcing\n    a round-trip (de)serialization.\n\n    Args:\n        task_logic: The task logic schema instance to set.\n        force: If True, allows overriding an existing task logic. Defaults to False.\n\n    Raises:\n        ValueError: If task logic is already set and force is False\n    \"\"\"\n    if self._task_logic is not None and not force:\n        raise ValueError(\"Task logic already set.\")\n    task_logic = self._task_logic_model.model_validate_json(task_logic.model_dump_json())\n    self._task_logic, self._task_logic_model = self._resolve_model(task_logic)\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.get_task_logic_model","title":"get_task_logic_model","text":"<pre><code>get_task_logic_model() -&gt; Type[TTaskLogic]\n</code></pre> <p>Returns the task logic schema model class.</p> <p>Returns:</p> Type Description <code>Type[TTaskLogic]</code> <p>Type[TTaskLogic]: The task logic schema model class</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def get_task_logic_model(self) -&gt; Type[TTaskLogic]:\n    \"\"\"\n    Returns the task logic schema model class.\n\n    Returns:\n        Type[TTaskLogic]: The task logic schema model class\n    \"\"\"\n    return self._task_logic_model\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.make_header","title":"make_header","text":"<pre><code>make_header() -&gt; str\n</code></pre> <p>Creates a formatted header string for the launcher.</p> <p>Generates a header containing the CLABE ASCII art logo and version information for the launcher and schema models.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted header string</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def make_header(self) -&gt; str:\n    \"\"\"\n    Creates a formatted header string for the launcher.\n\n    Generates a header containing the CLABE ASCII art logo and version information\n    for the launcher and schema models.\n\n    Returns:\n        str: The formatted header string\n    \"\"\"\n    _HEADER = r\"\"\"\n\n     \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n    \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557\n    \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d\n    \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n    \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n\n    Command-line-interface Launcher for AIND Behavior Experiments\n    Press Control+C to exit at any time.\n    \"\"\"\n\n    _str = (\n        \"-------------------------------\\n\"\n        f\"{_HEADER}\\n\"\n        f\"CLABE Version: {__version__}\\n\"\n        f\"TaskLogic ({self.get_task_logic_model().__name__}) Schema Version: {self.get_task_logic_model().model_construct().version}\\n\"\n        f\"Rig ({self.get_rig_model().__name__}) Schema Version: {self.get_rig_model().model_construct().version}\\n\"\n        f\"Session ({self.get_session_model().__name__}) Schema Version: {self.get_session_model().model_construct().version}\\n\"\n        \"-------------------------------\"\n    )\n\n    return _str\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.validate","title":"validate","text":"<pre><code>validate() -&gt; None\n</code></pre> <p>Validates the dependencies required for the launcher to run.</p> <p>Checks Git repository state, handles dirty repository conditions, and ensures all prerequisites are met for experiment execution.</p> Example <p>launcher = MyLauncher(...) try:     launcher.validate()     print(\"Validation successful\") except Exception as e:     print(f\"Validation failed: {e}\")</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def validate(self) -&gt; None:\n    \"\"\"\n    Validates the dependencies required for the launcher to run.\n\n    Checks Git repository state, handles dirty repository conditions,\n    and ensures all prerequisites are met for experiment execution.\n\n    Example:\n        launcher = MyLauncher(...)\n        try:\n            launcher.validate()\n            print(\"Validation successful\")\n        except Exception as e:\n            print(f\"Validation failed: {e}\")\n    \"\"\"\n    if self.repository.is_dirty():\n        logger.warning(\n            \"Git repository is dirty. Discard changes before continuing unless you know what you are doing!\"\n            \"Uncommitted files: %s\",\n            self.repository.uncommitted_changes(),\n        )\n        if not self.settings.allow_dirty:\n            self.repository.try_prompt_full_reset(self.ui_helper, force_reset=False)\n            if self.repository.is_dirty_with_submodules():\n                logger.error(\"Dirty repository not allowed. Exiting. Consider running with --allow-dirty flag.\")\n                raise RuntimeError(\"Dirty repository not allowed.\")\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.create_directory","title":"create_directory  <code>staticmethod</code>","text":"<pre><code>create_directory(directory: PathLike) -&gt; None\n</code></pre> <p>Creates a directory at the specified path if it does not already exist. To prevent deadlocks from network issues/auth, this function will run on a separate thread and timeout after 2 seconds.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>PathLike</code> <p>The path of the directory to create</p> required <p>Raises:</p> Type Description <code>OSError</code> <p>If the directory creation fails</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>@staticmethod\ndef create_directory(directory: os.PathLike) -&gt; None:\n    \"\"\"\n    Creates a directory at the specified path if it does not already exist.\n    To prevent deadlocks from network issues/auth, this function will run on a separate thread\n    and timeout after 2 seconds.\n\n    Args:\n        directory: The path of the directory to create\n\n    Raises:\n        OSError: If the directory creation fails\n    \"\"\"\n\n    def _create_directory_with_timeout():\n        if not os.path.exists(abspath(directory)):\n            logger.debug(\"Creating  %s\", directory)\n            try:\n                os.makedirs(directory)\n            except OSError as e:\n                logger.error(\"Failed to create directory %s: %s\", directory, e)\n                raise\n\n    thread = threading.Thread(target=_create_directory_with_timeout)\n    thread.start()\n    thread.join(timeout=2.0)\n\n    if thread.is_alive():\n        logger.error(\"Directory creation timed out after 2 seconds\")\n        raise TimeoutError(f\"Failed to create directory {directory} within 2 seconds\")\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Launcher.save_temp_model","title":"save_temp_model","text":"<pre><code>save_temp_model(\n    model: BaseModel, directory: Optional[PathLike] = None\n) -&gt; str\n</code></pre> <p>Saves a temporary JSON representation of a schema model.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Union[TRig, TSession, TTaskLogic]</code> <p>The schema model to save.</p> required <code>directory</code> <code>Optional[PathLike]</code> <p>The directory to save the file in.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The path to the saved file.</p> Source code in <code>src\\clabe\\launcher\\_base.py</code> <pre><code>def save_temp_model(self, model: pydantic.BaseModel, directory: Optional[os.PathLike] = None) -&gt; str:\n    \"\"\"\n    Saves a temporary JSON representation of a schema model.\n\n    Args:\n        model (Union[TRig, TSession, TTaskLogic]): The schema model to save.\n        directory (Optional[os.PathLike]): The directory to save the file in.\n\n    Returns:\n        str: The path to the saved file.\n    \"\"\"\n    directory = Path(directory) if directory is not None else Path(self.temp_dir)\n    os.makedirs(directory, exist_ok=True)\n    fname = model.__class__.__name__ + \".json\"\n    fpath = os.path.join(directory, fname)\n    with open(fpath, \"w+\", encoding=\"utf-8\") as f:\n        f.write(model.model_dump_json(indent=3))\n    return fpath\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.MaybeResult","title":"MaybeResult","text":"<pre><code>MaybeResult(result: R | _UnsetType = _UNSET)\n</code></pre> <p>               Bases: <code>Generic[R]</code></p> <p>A wrapper for the result of a function that may not return a value</p> <p>Initialize with either a result or None. Args:     result: The result of the function or _UNSET if not set.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def __init__(self, result: R | _UnsetType = _UNSET):\n    \"\"\"Initialize with either a result or None.\n    Args:\n        result: The result of the function or _UNSET if not set.\n    \"\"\"\n    self._result = result\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.MaybeResult.result","title":"result  <code>property</code>","text":"<pre><code>result: R\n</code></pre> <p>Get the result if the function returned a value, else raise an error.</p>"},{"location":"api/launcher/launcher/#clabe.launcher.MaybeResult.has_result","title":"has_result","text":"<pre><code>has_result() -&gt; bool\n</code></pre> <p>Check if the result is an exception.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def has_result(self) -&gt; bool:\n    \"\"\"Check if the result is an exception.\"\"\"\n    return self._result is not _UNSET\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise","title":"Promise","text":"<pre><code>Promise(callable: Callable[P, R])\n</code></pre> <p>               Bases: <code>Generic[P, R]</code></p> <p>A promise-like object that stores a callable and lazily evaluates its result.</p> <p>This class allows callables to be registered and their results to be accessed later through the .result property, enabling dependency chains between callables.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def __init__(self, callable: t.Callable[P, R]):\n    self._fn = callable\n    self._result: R | _UnsetType = _UNSET\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.result","title":"result  <code>property</code>","text":"<pre><code>result: R\n</code></pre> <p>Lazily evaluate and return the result of the callable.</p> <p>Returns:</p> Type Description <code>R</code> <p>The result of the callable execution.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the callable hasn't been executed yet.</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.callable","title":"callable  <code>property</code>","text":"<pre><code>callable: Callable[P, R]\n</code></pre> <p>Get the underlying callable.</p>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.invoke","title":"invoke","text":"<pre><code>invoke(*args: args, **kwargs: kwargs) -&gt; R\n</code></pre> <p>Execute the callable with the given value and store the result.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <p>The input value to pass to the callable</p> required <p>Returns:</p> Type Description <code>R</code> <p>The result of the callable execution</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def invoke(self, *args: P.args, **kwargs: P.kwargs) -&gt; R:\n    \"\"\"\n    Execute the callable with the given value and store the result.\n\n    Args:\n        value: The input value to pass to the callable\n\n    Returns:\n        The result of the callable execution\n    \"\"\"\n    if self.has_result():\n        assert not isinstance(self._result, _UnsetType)\n        return self._result\n    self._result = self._fn(*args, **kwargs)\n    return self._result\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.as_callable","title":"as_callable","text":"<pre><code>as_callable() -&gt; Callable[..., R]\n</code></pre> <p>Return a callable that returns the stored result, ignoring any arguments.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def as_callable(self) -&gt; t.Callable[..., R]:\n    \"\"\"Return a callable that returns the stored result, ignoring any arguments.\"\"\"\n    return lambda *args, **kwargs: self.result\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.has_result","title":"has_result","text":"<pre><code>has_result() -&gt; bool\n</code></pre> <p>Check if the callable has a result.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def has_result(self) -&gt; bool:\n    \"\"\"Check if the callable has a result.\"\"\"\n    return self._result is not _UNSET\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.Promise.from_value","title":"from_value  <code>classmethod</code>","text":"<pre><code>from_value(value: _T\" backlink-type=\"used-by\" backlink-anchor=\"clabe.launcher.Promise.from_value\" optional hover&gt;_T) -&gt; Promise[Any, _T]\n</code></pre> <p>Create a Promise from a resolved value.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>@classmethod\ndef from_value(cls, value: _T) -&gt; \"Promise[t.Any, _T]\":\n    \"\"\"Create a Promise from a resolved value.\"\"\"\n\n    # P is unconstrained here since we don't care about the input types\n    # as a result we will just use Any for the hinting.Any\n    # We will also use a new TypeVar just in case someone uses this method\n    # from an instance.\n    def _any_input(*args: t.Any, **kwargs: t.Any):\n        return value\n\n    promise = Promise[t.Any, _T](_any_input)\n    promise._result = value\n    return promise\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.TryResult","title":"TryResult","text":"<pre><code>TryResult(result: R | TException)\n</code></pre> <p>               Bases: <code>Generic[R, TException]</code></p> <p>A wrapper for the result of a function that may raise an exception.</p> <p>Initialize with either a result or an exception. Args:     result: The result of the function or an exception instance.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def __init__(self, result: R | TException):\n    \"\"\"Initialize with either a result or an exception.\n    Args:\n        result: The result of the function or an exception instance.\n    \"\"\"\n    self._result = result\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.TryResult.result","title":"result  <code>property</code>","text":"<pre><code>result: R\n</code></pre> <p>Get the result if it's not an exception, else raise an error.</p>"},{"location":"api/launcher/launcher/#clabe.launcher.TryResult.exception","title":"exception  <code>property</code>","text":"<pre><code>exception: Optional[TException]\n</code></pre> <p>Get the exception if it exists, else return None.</p>"},{"location":"api/launcher/launcher/#clabe.launcher.TryResult.has_exception","title":"has_exception","text":"<pre><code>has_exception() -&gt; bool\n</code></pre> <p>Check if the result is an exception.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def has_exception(self) -&gt; bool:\n    \"\"\"Check if the result is an exception.\"\"\"\n    return isinstance(self._result, BaseException)\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.TryResult.raise_from_exception","title":"raise_from_exception","text":"<pre><code>raise_from_exception() -&gt; None\n</code></pre> <p>Raise the stored exception if it exists.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def raise_from_exception(self) -&gt; None:\n    \"\"\"Raise the stored exception if it exists.\"\"\"\n    if self.has_exception():\n        assert isinstance(self._result, BaseException)\n        raise self._result  # type: ignore[raise-value]\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs","title":"LauncherCliArgs","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Base class for CLI arguments using Pydantic for validation and configuration.</p> <p>Attributes:</p> Name Type Description <code>data_dir</code> <code>PathLike</code> <p>The data directory where to save the data.</p> <code>repository_dir</code> <code>Optional[PathLike]</code> <p>The repository root directory.</p> <code>debug_mode</code> <code>CliImplicitFlag[bool]</code> <p>Whether to run in debug mode.</p> <code>allow_dirty</code> <code>CliImplicitFlag[bool]</code> <p>Whether to allow running with a dirty repository.</p> <code>skip_hardware_validation</code> <code>CliImplicitFlag[bool]</code> <p>Whether to skip hardware validation.</p> <code>subject</code> <code>Optional[str]</code> <p>The name of the subject. If None, will be prompted later.</p> <code>task_logic_path</code> <code>Optional[PathLike]</code> <p>Path to the task logic schema. If None, will be prompted later.</p> <code>rig_path</code> <code>Optional[PathLike]</code> <p>Path to the rig schema. If None, will be prompted later.</p> <code>temp_dir</code> <code>PathLike</code> <p>Directory used for launcher temp files.</p> Example"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs--create-cli-args-from-command-line","title":"Create CLI args from command line","text":"<p>args = LauncherCliArgs()</p>"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs--create-with-specific-values","title":"Create with specific values","text":"<p>args = LauncherCliArgs(     data_dir=\"/path/to/data\",     debug_mode=True,     subject=\"mouse_001\" )</p>"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs--access-properties","title":"Access properties","text":"<p>print(f\"Data directory: {args.data_dir}\") print(f\"Debug mode: {args.debug_mode}\")</p>"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the order of settings sources for the CLI.</p> <p>Defines the priority order for configuration sources, with initialization settings taking precedence, followed by YAML files, environment variables, dotenv files, and finally file secrets.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>Initial settings source</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>Environment variable settings source</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>Dotenv settings source</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>File secret settings source</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>Tuple[PydanticBaseSettingsSource, ...]: Ordered tuple of settings sources</p> Example Source code in <code>src\\clabe\\launcher\\_cli.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the order of settings sources for the CLI.\n\n    Defines the priority order for configuration sources, with initialization settings\n    taking precedence, followed by YAML files, environment variables, dotenv files,\n    and finally file secrets.\n\n    Args:\n        settings_cls: The settings class\n        init_settings: Initial settings source\n        env_settings: Environment variable settings source\n        dotenv_settings: Dotenv settings source\n        file_secret_settings: File secret settings source\n\n    Returns:\n        Tuple[PydanticBaseSettingsSource, ...]: Ordered tuple of settings sources\n\n    Example:\n        # This method is automatically called by Pydantic\n        # when creating a LauncherCliArgs instance. Settings are loaded\n        # in this priority order:\n        # 1. init_settings (constructor arguments)\n        # 2. YAML config files\n        # 3. Environment variables\n        # 4. .env files\n        # 5. File secrets\n        args = LauncherCliArgs(data_dir=\"/override/path\")  # init_settings\n    \"\"\"\n    return (\n        init_settings,\n        YamlConfigSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--this-method-is-automatically-called-by-pydantic","title":"This method is automatically called by Pydantic","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--when-creating-a-launchercliargs-instance-settings-are-loaded","title":"when creating a LauncherCliArgs instance. Settings are loaded","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--in-this-priority-order","title":"in this priority order:","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--1-init_settings-constructor-arguments","title":"1. init_settings (constructor arguments)","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--2-yaml-config-files","title":"2. YAML config files","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--3-environment-variables","title":"3. Environment variables","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--4-env-files","title":"4. .env files","text":""},{"location":"api/launcher/launcher/#clabe.launcher.LauncherCliArgs.settings_customise_sources--5-file-secrets","title":"5. File secrets","text":"<p>args = LauncherCliArgs(data_dir=\"/override/path\")  # init_settings</p>"},{"location":"api/launcher/launcher/#clabe.launcher.ignore_errors","title":"ignore_errors","text":"<pre><code>ignore_errors(\n    exception_types: Union[\n        Type[BaseException], Tuple[Type[BaseException], ...]\n    ] = Exception,\n    default_return: Any = None,\n) -&gt; Callable[\n    [Callable[P, R]], Callable[P, Optional[R]]\n]\n</code></pre> <p>A decorator that implements try-catch for the wrapped function.</p> <p>Parameters:</p> Name Type Description Default <code>exception_types</code> <code>Union[Type[BaseException], Tuple[Type[BaseException], ...]]</code> <p>Exception type(s) to catch (default: Exception)</p> <code>Exception</code> <code>default_return</code> <code>Any</code> <p>Value to return if exception is caught (default: None)</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, Optional[R]]]</code> <p>The decorated function with exception handling</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def ignore_errors(\n    exception_types: t.Union[t.Type[BaseException], t.Tuple[t.Type[BaseException], ...]] = Exception,\n    default_return: t.Any = None,\n) -&gt; t.Callable[[t.Callable[P, R]], t.Callable[P, Optional[R]]]:\n    \"\"\"\n    A decorator that implements try-catch for the wrapped function.\n\n    Args:\n        exception_types: Exception type(s) to catch (default: Exception)\n        default_return: Value to return if exception is caught (default: None)\n\n    Returns:\n        The decorated function with exception handling\n    \"\"\"\n\n    def decorator(func: t.Callable) -&gt; t.Callable:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            try:\n                return func(*args, **kwargs)\n            except exception_types as e:\n                fn_name = getattr(func, \"__name__\", repr(func))\n                logger.warning(f\"Exception in {fn_name}: {e}\")\n                return default_return\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.run_if","title":"run_if","text":"<pre><code>run_if(\n    predicate: Callable[..., bool],\n    *predicate_args,\n    **predicate_kwargs,\n) -&gt; Callable[\n    [Callable[P, R]], Callable[P, MaybeResult[R]]\n]\n</code></pre> <p>A decorator that only runs the wrapped function if the predicate returns True.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[..., bool]</code> <p>A callable that returns a boolean.</p> required <code>*predicate_args</code> <p>Arguments to pass to the predicate.</p> <code>()</code> <code>**predicate_kwargs</code> <p>Keyword arguments to pass to the predicate.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, MaybeResult[R]]]</code> <p>The decorated function that runs only if predicate(predicate_args, *predicate_kwargs) is True.</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def run_if(\n    predicate: t.Callable[..., bool], *predicate_args, **predicate_kwargs\n) -&gt; t.Callable[[t.Callable[P, R]], t.Callable[P, MaybeResult[R]]]:\n    \"\"\"\n    A decorator that only runs the wrapped function if the predicate returns True.\n\n    Args:\n        predicate: A callable that returns a boolean.\n        *predicate_args: Arguments to pass to the predicate.\n        **predicate_kwargs: Keyword arguments to pass to the predicate.\n\n    Returns:\n        The decorated function that runs only if predicate(*predicate_args, **predicate_kwargs) is True.\n    \"\"\"\n\n    def decorator(func: t.Callable[P, R]) -&gt; t.Callable[P, MaybeResult[R]]:\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            fn_name = getattr(func, \"__name__\", repr(func))\n            if predicate(*predicate_args, **predicate_kwargs):\n                logger.debug(f\"Predicate passed for {fn_name}, executing function\")\n                return MaybeResult(func(*args, **kwargs))\n            logger.debug(f\"Predicate failed for {fn_name}, skipping execution\")\n            return MaybeResult()\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/launcher/launcher/#clabe.launcher.try_catch","title":"try_catch","text":"<pre><code>try_catch(\n    exception_types: Union[\n        Type[TException], Tuple[Type[TException], ...]\n    ] = Exception,\n) -&gt; Callable[\n    [Callable[P, R]],\n    Callable[P, TryResult[R, TException]],\n]\n</code></pre> <p>A decorator that implements try-catch for the wrapped function.</p> <p>Parameters:</p> Name Type Description Default <code>exception_types</code> <code>Union[Type[TException], Tuple[Type[TException], ...]]</code> <p>Exception type(s) to catch (default: Exception)</p> <code>Exception</code> <p>Returns:</p> Type Description <code>Callable[[Callable[P, R]], Callable[P, TryResult[R, TException]]]</code> <p>The decorated function with exception handling that returns a _TryResult</p> Source code in <code>src\\clabe\\launcher\\_callable_manager.py</code> <pre><code>def try_catch(\n    exception_types: t.Union[t.Type[TException], t.Tuple[t.Type[TException], ...]] = Exception,  # type: ignore[assignment]\n) -&gt; t.Callable[[t.Callable[P, R]], t.Callable[P, TryResult[R, TException]]]:\n    \"\"\"\n    A decorator that implements try-catch for the wrapped function.\n\n    Args:\n        exception_types: Exception type(s) to catch (default: Exception)\n\n    Returns:\n        The decorated function with exception handling that returns a _TryResult\n    \"\"\"\n\n    def decorator(func: t.Callable[P, R]) -&gt; t.Callable[P, TryResult[R, TException]]:\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; TryResult[R, TException]:\n            try:\n                return TryResult(func(*args, **kwargs))\n            except exception_types as e:\n                fn_name = getattr(func, \"__name__\", repr(func))\n                logger.warning(f\"Exception in {fn_name}: {e}. Returning exception instance.\")\n                return TryResult(e)\n\n        return wrapper\n\n    return decorator\n</code></pre>"},{"location":"api/logging_helper/aibs/","title":"logging_helper.aibs","text":""},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.AibsLogServerHandlerSettings","title":"AibsLogServerHandlerSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the AIBS log server handler.</p> <p>Attributes:</p> Name Type Description <code>rig_id</code> <code>str</code> <p>The ID of the rig.</p> <code>comp_id</code> <code>str</code> <p>The ID of the computer.</p> <code>project_name</code> <code>str</code> <p>The name of the project.</p> <code>version</code> <code>str</code> <p>The version of the project.</p> <code>host</code> <code>str</code> <p>The hostname of the log server.</p> <code>port</code> <code>int</code> <p>The port of the log server.</p> <code>level</code> <code>int</code> <p>The logging level.</p>"},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.AibsLogServerHandlerSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.AibsLogServerHandler","title":"AibsLogServerHandler","text":"<pre><code>AibsLogServerHandler(\n    settings: AibsLogServerHandlerSettings, *args, **kwargs\n)\n</code></pre> <p>               Bases: <code>SocketHandler</code></p> <p>A custom logging handler that sends log records to the AIBS log server.</p> <p>This handler extends the standard SocketHandler to include project-specific metadata in the log records before sending them to the log server.</p> <p>Attributes:</p> Name Type Description <code>project_name</code> <code>str</code> <p>The name of the project.</p> <code>version</code> <code>str</code> <p>The version of the project.</p> <code>rig_id</code> <code>str</code> <p>The ID of the rig.</p> <code>comp_id</code> <code>str</code> <p>The ID of the computer.</p> <p>Examples:</p> <pre><code>import logging\nfrom clabe.logging_helper.aibs import AibsLogServerHandler, AibsLogServerHandlerSettings\n\n# Initialize the handler with settings\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000\n)\nhandler = AibsLogServerHandler(settings=settings)\n\n# Initialize with custom level\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000,\n    level=logging.WARNING\n)\nhandler = AibsLogServerHandler(settings=settings)\n</code></pre> <p>Initializes the AIBS log server handler.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>AibsLogServerHandlerSettings</code> <p>AibsLogServerHandlerSettings containing all configuration options</p> required <code>*args</code> <p>Additional arguments to pass to the SocketHandler.</p> <code>()</code> <code>**kwargs</code> <p>Additional keyword arguments to pass to the SocketHandler.</p> <code>{}</code> Source code in <code>src\\clabe\\logging_helper\\aibs.py</code> <pre><code>def __init__(\n    self,\n    settings: AibsLogServerHandlerSettings,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the AIBS log server handler.\n\n    Args:\n        settings: AibsLogServerHandlerSettings containing all configuration options\n        *args: Additional arguments to pass to the SocketHandler.\n        **kwargs: Additional keyword arguments to pass to the SocketHandler.\n    \"\"\"\n    super().__init__(settings.host, settings.port, *args, **kwargs)\n    self.setLevel(settings.level)\n    self._settings = settings\n\n    self.formatter = logging.Formatter(\n        fmt=\"%(asctime)s\\n%(name)s\\n%(levelname)s\\n%(funcName)s (%(filename)s:%(lineno)d)\\n%(message)s\",\n        datefmt=\"%Y-%m-%d %H:%M:%S\",\n    )\n</code></pre>"},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.AibsLogServerHandler.emit","title":"emit","text":"<pre><code>emit(record: LogRecord) -&gt; None\n</code></pre> <p>Emits a log record.</p> <p>Adds project-specific information to the log record before emitting it.</p> <p>Parameters:</p> Name Type Description Default <code>record</code> <code>LogRecord</code> <p>The log record to emit.</p> required Source code in <code>src\\clabe\\logging_helper\\aibs.py</code> <pre><code>def emit(self, record: logging.LogRecord) -&gt; None:\n    \"\"\"\n    Emits a log record.\n\n    Adds project-specific information to the log record before emitting it.\n\n    Args:\n        record: The log record to emit.\n    \"\"\"\n    record.project = self._settings.project_name\n    record.rig_id = self._settings.rig_id\n    record.comp_id = self._settings.comp_id\n    record.version = self._settings.version\n    record.extra = None  # set extra to None because this sends a pickled record\n    super().emit(record)\n</code></pre>"},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.add_handler","title":"add_handler","text":"<pre><code>add_handler(\n    logger: TLogger, settings: AibsLogServerHandlerSettings\n) -&gt; TLogger\n</code></pre> <p>Adds an AIBS log server handler to the logger.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>TLogger</code> <p>The logger to add the handler to.</p> required <code>settings</code> <code>AibsLogServerHandlerSettings</code> <p>AibsLogServerHandlerSettings containing configuration options</p> required <p>Returns:</p> Type Description <code>TLogger</code> <p>The logger with the added handler.</p> <p>Examples:</p> <pre><code>import logging\nfrom clabe.logging_helper.aibs import add_handler, AibsLogServerHandlerSettings\n\n# Create a logger\nlogger = logging.getLogger('my_logger')\nlogger.setLevel(logging.INFO)\n\n# Add the AIBS log server handler with default ERROR level\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000\n)\nlogger = add_handler(logger, settings)\n\n# Add handler with custom level\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000,\n    level=logging.WARNING\n)\nlogger = add_handler(logger, settings)\n</code></pre> Source code in <code>src\\clabe\\logging_helper\\aibs.py</code> <pre><code>def add_handler(\n    logger: TLogger,\n    settings: AibsLogServerHandlerSettings,\n) -&gt; TLogger:\n    \"\"\"\n    Adds an AIBS log server handler to the logger.\n\n    Args:\n        logger: The logger to add the handler to.\n        settings: AibsLogServerHandlerSettings containing configuration options\n\n    Returns:\n        The logger with the added handler.\n\n    Examples:\n        ```python\n        import logging\n        from clabe.logging_helper.aibs import add_handler, AibsLogServerHandlerSettings\n\n        # Create a logger\n        logger = logging.getLogger('my_logger')\n        logger.setLevel(logging.INFO)\n\n        # Add the AIBS log server handler with default ERROR level\n        settings = AibsLogServerHandlerSettings(\n            project_name='my_project',\n            version='1.0.0',\n            host='localhost',\n            port=5000\n        )\n        logger = add_handler(logger, settings)\n\n        # Add handler with custom level\n        settings = AibsLogServerHandlerSettings(\n            project_name='my_project',\n            version='1.0.0',\n            host='localhost',\n            port=5000,\n            level=logging.WARNING\n        )\n        logger = add_handler(logger, settings)\n        ```\n    \"\"\"\n    socket_handler = AibsLogServerHandler(settings=settings)\n    logger.addHandler(socket_handler)\n    return logger\n</code></pre>"},{"location":"api/logging_helper/aibs/#clabe.logging_helper.aibs.attach_to_launcher","title":"attach_to_launcher","text":"<pre><code>attach_to_launcher(\n    launcher: TLauncher,\n    settings: AibsLogServerHandlerSettings,\n) -&gt; TLauncher\n</code></pre> <p>Attaches an AIBS log server handler to a launcher instance.</p> <p>Parameters:</p> Name Type Description Default <code>launcher</code> <code>TLauncher</code> <p>The launcher instance to attach the handler to.</p> required <code>settings</code> <code>AibsLogServerHandlerSettings</code> <p>AibsLogServerHandlerSettings containing configuration options</p> required <p>Returns:</p> Type Description <code>TLauncher</code> <p>The launcher instance with the attached handler.</p> <p>Examples:</p> <pre><code>import logging\nfrom clabe.launcher import Launcher\nfrom clabe.logging_helper.aibs import attach_to_launcher, AibsLogServerHandlerSettings\n\n# Initialize the launcher\nlauncher = MyLauncher(...) # Replace with your custom launcher class\n\n# Attach the AIBS log server handler with default ERROR level\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_launcher_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000\n)\nlauncher = attach_to_launcher(launcher, settings)\n\n# Attach handler with custom level\nsettings = AibsLogServerHandlerSettings(\n    project_name='my_launcher_project',\n    version='1.0.0',\n    host='localhost',\n    port=5000,\n    level=logging.WARNING\n)\nlauncher = attach_to_launcher(launcher, settings)\n</code></pre> Source code in <code>src\\clabe\\logging_helper\\aibs.py</code> <pre><code>def attach_to_launcher(launcher: TLauncher, settings: AibsLogServerHandlerSettings) -&gt; TLauncher:\n    \"\"\"\n    Attaches an AIBS log server handler to a launcher instance.\n\n    Args:\n        launcher: The launcher instance to attach the handler to.\n        settings: AibsLogServerHandlerSettings containing configuration options\n\n    Returns:\n        The launcher instance with the attached handler.\n\n    Examples:\n        ```python\n        import logging\n        from clabe.launcher import Launcher\n        from clabe.logging_helper.aibs import attach_to_launcher, AibsLogServerHandlerSettings\n\n        # Initialize the launcher\n        launcher = MyLauncher(...) # Replace with your custom launcher class\n\n        # Attach the AIBS log server handler with default ERROR level\n        settings = AibsLogServerHandlerSettings(\n            project_name='my_launcher_project',\n            version='1.0.0',\n            host='localhost',\n            port=5000\n        )\n        launcher = attach_to_launcher(launcher, settings)\n\n        # Attach handler with custom level\n        settings = AibsLogServerHandlerSettings(\n            project_name='my_launcher_project',\n            version='1.0.0',\n            host='localhost',\n            port=5000,\n            level=logging.WARNING\n        )\n        launcher = attach_to_launcher(launcher, settings)\n        ```\n    \"\"\"\n\n    add_handler(\n        launcher.logger,\n        settings=settings,\n    )\n    return launcher\n</code></pre>"},{"location":"api/logging_helper/logging_helper/","title":"logging_helper","text":""},{"location":"api/logging_helper/logging_helper/#clabe.logging_helper.add_file_handler","title":"add_file_handler","text":"<pre><code>add_file_handler(\n    logger: TLogger, output_path: PathLike\n) -&gt; TLogger\n</code></pre> <p>Adds a file handler to the logger to write logs to a file.</p> <p>Creates a new file handler with UTC timezone formatting and adds it to the specified logger for persistent log storage.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>TLogger</code> <p>The logger to which the file handler will be added</p> required <code>output_path</code> <code>PathLike</code> <p>The path to the log file</p> required <p>Returns:</p> Name Type Description <code>TLogger</code> <code>TLogger</code> <p>The logger with the added file handler</p> Source code in <code>src\\clabe\\logging_helper\\_stdlib.py</code> <pre><code>def add_file_handler(logger: TLogger, output_path: os.PathLike) -&gt; TLogger:\n    \"\"\"\n    Adds a file handler to the logger to write logs to a file.\n\n    Creates a new file handler with UTC timezone formatting and adds it to the\n    specified logger for persistent log storage.\n\n    Args:\n        logger: The logger to which the file handler will be added\n        output_path: The path to the log file\n\n    Returns:\n        TLogger: The logger with the added file handler\n    \"\"\"\n    file_handler = logging.FileHandler(Path(output_path), encoding=\"utf-8\", mode=\"w\")\n    file_handler.setFormatter(utc_formatter)\n    logger.addHandler(file_handler)\n    return logger\n</code></pre>"},{"location":"api/logging_helper/logging_helper/#clabe.logging_helper.close_file_handlers","title":"close_file_handlers","text":"<pre><code>close_file_handlers(logger: TLogger) -&gt; TLogger\n</code></pre> <p>Closes all file handlers associated with the logger.</p> <p>Iterates through all handlers associated with the logger and closes any file handlers to ensure proper resource cleanup.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>TLogger</code> <p>The logger whose file handlers will be closed</p> required <p>Returns:</p> Name Type Description <code>TLogger</code> <code>TLogger</code> <p>The logger with closed file handlers</p> Source code in <code>src\\clabe\\logging_helper\\_stdlib.py</code> <pre><code>def close_file_handlers(logger: TLogger) -&gt; TLogger:\n    \"\"\"\n    Closes all file handlers associated with the logger.\n\n    Iterates through all handlers associated with the logger and closes any\n    file handlers to ensure proper resource cleanup.\n\n    Args:\n        logger: The logger whose file handlers will be closed\n\n    Returns:\n        TLogger: The logger with closed file handlers\n    \"\"\"\n    for handler in logger.handlers:\n        if isinstance(handler, logging.FileHandler):\n            handler.close()\n    return logger\n</code></pre>"},{"location":"api/logging_helper/logging_helper/#clabe.logging_helper.shutdown_logger","title":"shutdown_logger","text":"<pre><code>shutdown_logger(logger: TLogger) -&gt; TLogger\n</code></pre> <p>Shuts down the logger by closing all file handlers and calling logging.shutdown().</p> <p>Performs a complete shutdown of the logging system, ensuring all file handlers are properly closed and resources are released.</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>TLogger</code> <p>The logger to shut down</p> required <p>Returns:</p> Name Type Description <code>TLogger</code> <code>TLogger</code> <p>The logger with closed file handlers</p> Source code in <code>src\\clabe\\logging_helper\\_stdlib.py</code> <pre><code>def shutdown_logger(logger: TLogger) -&gt; TLogger:\n    \"\"\"\n    Shuts down the logger by closing all file handlers and calling logging.shutdown().\n\n    Performs a complete shutdown of the logging system, ensuring all file handlers\n    are properly closed and resources are released.\n\n    Args:\n        logger: The logger to shut down\n\n    Returns:\n        TLogger: The logger with closed file handlers\n    \"\"\"\n    close_file_handlers(logger)\n    logging.shutdown()\n    return logger\n</code></pre>"},{"location":"api/pickers/dataverse/","title":"pickers.dataverse","text":""},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataverseSuggestion","title":"DataverseSuggestion","text":"<p>               Bases: <code>BaseModel</code></p> <p>Internal representation of a suggestion entry in Dataverse.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataverseSuggestion.validate_trainer_state","title":"validate_trainer_state  <code>classmethod</code>","text":"<pre><code>validate_trainer_state(value)\n</code></pre> <p>Validate and convert the trainer_state field from a JSON string to a TrainerState object.</p> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>@field_validator(\"trainer_state\", mode=\"before\")\n@classmethod\ndef validate_trainer_state(cls, value):\n    \"\"\"\n    Validate and convert the trainer_state field from a JSON string to a TrainerState object.\n    \"\"\"\n    if value is None:\n        return value\n    if isinstance(value, str):\n        return TrainerState.model_validate_json(value)\n    return value\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataverseSuggestion.from_request_output","title":"from_request_output  <code>classmethod</code>","text":"<pre><code>from_request_output(\n    subject: str, request_output: dict\n) -&gt; DataverseSuggestion\n</code></pre> <p>Create a _Suggestion instance from a dictionary of data.</p> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>@classmethod\ndef from_request_output(cls, subject: str, request_output: dict) -&gt; \"DataverseSuggestion\":\n    \"\"\"\n    Create a _Suggestion instance from a dictionary of data.\n    \"\"\"\n    trainer_state = request_output.get(\"aibs_trainer_state\", None)\n    trainer_state = TrainerState.model_validate_json(cls._strip_html(trainer_state)) if trainer_state else None\n    return cls(\n        subject_id=subject,\n        trainer_state=trainer_state,\n        task_name=request_output.get(\"aibs_task_name\", None),\n        stage_name=request_output.get(\"aibs_stage_name\", None),\n        modified_on=request_output.get(\"modifiedon\", None),\n        created_on=request_output.get(\"createdon\", None),\n    )\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataverseSuggestion.from_trainer_state","title":"from_trainer_state  <code>classmethod</code>","text":"<pre><code>from_trainer_state(\n    subject: str, trainer_state: TrainerState\n) -&gt; DataverseSuggestion\n</code></pre> <p>Create a _Suggestion instance from a TrainerState object.</p> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>@classmethod\ndef from_trainer_state(cls, subject: str, trainer_state: TrainerState) -&gt; \"DataverseSuggestion\":\n    \"\"\"\n    Create a _Suggestion instance from a TrainerState object.\n    \"\"\"\n    if trainer_state is None:\n        raise ValueError(\"trainer_state cannot be None\")\n    if trainer_state.stage is None:\n        raise ValueError(\"trainer_state.stage cannot be None\")\n    return cls(\n        subject_id=subject,\n        trainer_state=trainer_state,\n        task_name=trainer_state.stage.task.name,\n        stage_name=trainer_state.stage.name,\n    )\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker","title":"DataversePicker","text":"<pre><code>DataversePicker(\n    *,\n    dataverse_client: Optional[_DataverseRestClient] = None,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[UiHelper] = None,\n    experimenter_validator: Optional[\n        Callable[[str], bool]\n    ] = validate_aind_username,\n)\n</code></pre> <p>               Bases: <code>DefaultBehaviorPicker</code>, <code>Generic[TRig, TSession, TTaskLogic]</code></p> <p>Picker that integrates with Dataverse to fetch and push trainer state suggestions.</p> <p>Initializes the DataversePicker.</p> <p>Parameters:</p> Name Type Description Default <code>dataverse_client</code> <code>Optional[_DataverseRestClient]</code> <p>Optional Dataverse REST client for making API calls. If not provided, a new client will be created using settings from KeePass.</p> <code>None</code> <code>settings</code> <code>DefaultBehaviorPickerSettings</code> <p>Settings containing configuration including config_library_dir</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>Helper for user interface interactions</p> <code>None</code> <code>experimenter_validator</code> <code>Optional[Callable[[str], bool]]</code> <p>Function to validate the experimenter's username. If None, no validation is performed</p> <code>validate_aind_username</code> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>def __init__(\n    self,\n    *,\n    dataverse_client: Optional[_DataverseRestClient] = None,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[ui.UiHelper] = None,\n    experimenter_validator: Optional[Callable[[str], bool]] = validate_aind_username,\n):\n    \"\"\"\n    Initializes the DataversePicker.\n\n    Args:\n        dataverse_client: Optional Dataverse REST client for making API calls. If not provided, a new client will be created using settings from KeePass.\n        settings: Settings containing configuration including config_library_dir\n        ui_helper: Helper for user interface interactions\n        experimenter_validator: Function to validate the experimenter's username. If None, no validation is performed\n    \"\"\"\n    super().__init__(settings=settings, ui_helper=ui_helper, experimenter_validator=experimenter_validator)\n    self._dataverse_client = (\n        dataverse_client\n        if dataverse_client is not None\n        else _DataverseRestClient(_DataverseRestClientSettings.from_keepass())\n    )\n    self._dataverse_suggestion: Optional[DataverseSuggestion] = None\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.has_ui_helper","title":"has_ui_helper  <code>property</code>","text":"<pre><code>has_ui_helper: bool\n</code></pre> <p>Checks if a UI helper is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a UI helper is registered, False otherwise</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.ui_helper","title":"ui_helper  <code>property</code>","text":"<pre><code>ui_helper: UiHelper\n</code></pre> <p>Retrieves the registered UI helper.</p> <p>Returns:</p> Name Type Description <code>DefaultUIHelper</code> <code>UiHelper</code> <p>The registered UI helper</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no UI helper is registered</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.trainer_state","title":"trainer_state  <code>property</code>","text":"<pre><code>trainer_state: TrainerState\n</code></pre> <p>Returns the current trainer state.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The current trainer state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the trainer state is not set.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.config_library_dir","title":"config_library_dir  <code>property</code>","text":"<pre><code>config_library_dir: Path\n</code></pre> <p>Returns the path to the configuration library directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The configuration library directory.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.rig_dir","title":"rig_dir  <code>property</code>","text":"<pre><code>rig_dir: Path\n</code></pre> <p>Returns the path to the rig configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The rig configuration directory.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.subject_dir","title":"subject_dir  <code>property</code>","text":"<pre><code>subject_dir: Path\n</code></pre> <p>Returns the path to the subject configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The subject configuration directory.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.task_logic_dir","title":"task_logic_dir  <code>property</code>","text":"<pre><code>task_logic_dir: Path\n</code></pre> <p>Returns the path to the task logic configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The task logic configuration directory.</p>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.pick_trainer_state","title":"pick_trainer_state","text":"<pre><code>pick_trainer_state(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TrainerState\n</code></pre> <p>Prompts the user to select or create a trainer state configuration.</p> <p>Attempts to load trainer state in the following order: 1. If task_logic already exists in launcher, will return an empty TrainerState 2. From subject-specific folder</p> <p>It will launcher.set_task_logic if the deserialized TrainerState is valid.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The deserialized TrainerState object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>def pick_trainer_state(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TrainerState:\n    \"\"\"\n    Prompts the user to select or create a trainer state configuration.\n\n    Attempts to load trainer state in the following order:\n    1. If task_logic already exists in launcher, will return an empty TrainerState\n    2. From subject-specific folder\n\n    It will launcher.set_task_logic if the deserialized TrainerState is valid.\n\n    Returns:\n        TrainerState: The deserialized TrainerState object.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (launcher.get_task_logic()) is not None:\n        logger.debug(\"Task logic already set in launcher. Cannot inject a trainer state.\")\n        self._trainer_state = TrainerState(curriculum=None, stage=None, is_on_curriculum=False)\n    else:\n        if launcher.subject is None:\n            logger.error(\"No subject set in launcher. Cannot load trainer state.\")\n            raise ValueError(\"No subject set in launcher.\")\n        task_logic_name = launcher.get_task_logic_model().model_fields[\"name\"].default\n        if not task_logic_name:\n            raise ValueError(\"Task logic model does not have a default name.\")\n        try:\n            logger.debug(\"Attempting to load trainer state dataverse\")\n            last_suggestions = _get_last_suggestions(self._dataverse_client, launcher.subject, task_logic_name, 1)\n        except requests.exceptions.HTTPError as e:\n            logger.error(\"Failed to fetch suggestions from Dataverse: %s\", e)\n            raise\n        except pydantic.ValidationError as e:\n            logger.error(\"Failed to validate suggestion from Dataverse: %s\", e)\n            raise\n        if len(last_suggestions) == 0:\n            raise ValueError(\n                f\"No valid suggestions found in Dataverse for subject {launcher.subject} with task {task_logic_name}.\"\n            )\n\n        _dataverse_suggestion = last_suggestions[0]\n\n        assert _dataverse_suggestion is not None\n        if _dataverse_suggestion.trainer_state is None:\n            raise ValueError(\"No trainer state found in the latest suggestion.\")\n        if _dataverse_suggestion.trainer_state.stage is None:\n            raise ValueError(\"No stage found in the latest suggestion's trainer state.\")\n        self._dataverse_suggestion = _dataverse_suggestion\n        self._trainer_state = _dataverse_suggestion.trainer_state\n        launcher.set_task_logic(_dataverse_suggestion.trainer_state.stage.task)\n\n    assert self._trainer_state is not None\n    if not self._trainer_state.is_on_curriculum:\n        logging.warning(\"Deserialized TrainerState is NOT on curriculum.\")\n    self._sync_session_metadata(launcher)\n    return self.trainer_state\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.push_new_suggestion","title":"push_new_suggestion","text":"<pre><code>push_new_suggestion(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    trainer_state: TrainerState,\n) -&gt; None\n</code></pre> <p>Pushes a new suggestion to Dataverse for the current subject in the launcher. Args:     launcher: The Launcher instance containing the current session and subject information.     trainer_state: The TrainerState object to be pushed as a new suggestion.</p> Source code in <code>src\\clabe\\pickers\\dataverse.py</code> <pre><code>def push_new_suggestion(self, launcher: Launcher[TRig, TSession, TTaskLogic], trainer_state: TrainerState) -&gt; None:\n    \"\"\"\n    Pushes a new suggestion to Dataverse for the current subject in the launcher.\n    Args:\n        launcher: The Launcher instance containing the current session and subject information.\n        trainer_state: The TrainerState object to be pushed as a new suggestion.\n    \"\"\"\n    logger.info(\"Pushing new suggestion to Dataverse for subject %s\", launcher.get_session(strict=True).subject)\n    _append_suggestion(self._dataverse_client, launcher.get_session(strict=True).subject, trainer_state)\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.register_ui_helper","title":"register_ui_helper","text":"<pre><code>register_ui_helper(ui_helper: UiHelper) -&gt; Self\n</code></pre> <p>Registers a UI helper with the picker.</p> <p>Associates a UI helper instance with this picker for user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>ui_helper</code> <code>UiHelper</code> <p>The UI helper to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The picker instance for method chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a UI helper is already registered</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def register_ui_helper(self, ui_helper: ui.UiHelper) -&gt; Self:\n    \"\"\"\n    Registers a UI helper with the picker.\n\n    Associates a UI helper instance with this picker for user interactions.\n\n    Args:\n        ui_helper: The UI helper to register\n\n    Returns:\n        Self: The picker instance for method chaining\n\n    Raises:\n        ValueError: If a UI helper is already registered\n    \"\"\"\n    if self._ui_helper is None:\n        self._ui_helper = ui_helper\n    else:\n        raise ValueError(\"UI Helper is already registered\")\n    return self\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.initialize","title":"initialize","text":"<pre><code>initialize(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; None\n</code></pre> <p>Initializes the picker by creating required directories if needed.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def initialize(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; None:\n    \"\"\"\n    Initializes the picker by creating required directories if needed.\n    \"\"\"\n    self._launcher = launcher\n    self._ui_helper = launcher.ui_helper\n    self._ensure_directories(launcher)\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.pick_rig","title":"pick_rig","text":"<pre><code>pick_rig(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TRig\n</code></pre> <p>Prompts the user to select a rig configuration file.</p> <p>Searches for available rig configuration files and either automatically selects a single file or prompts the user to choose from multiple options.</p> <p>Returns:</p> Name Type Description <code>TRig</code> <code>TRig</code> <p>The selected rig configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rig configuration files are found or an invalid choice is made.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_rig(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TRig:\n    \"\"\"\n    Prompts the user to select a rig configuration file.\n\n    Searches for available rig configuration files and either automatically\n    selects a single file or prompts the user to choose from multiple options.\n\n    Returns:\n        TRig: The selected rig configuration.\n\n    Raises:\n        ValueError: If no rig configuration files are found or an invalid choice is made.\n    \"\"\"\n    rig = launcher.get_rig()\n    if rig is not None:\n        logger.info(\"Rig already set in launcher. Using existing rig.\")\n        return rig\n    available_rigs = glob.glob(os.path.join(self.rig_dir, \"*.json\"))\n    if len(available_rigs) == 0:\n        logger.error(\"No rig config files found.\")\n        raise ValueError(\"No rig config files found.\")\n    elif len(available_rigs) == 1:\n        logger.info(\"Found a single rig config file. Using %s.\", {available_rigs[0]})\n        rig = model_from_json_file(available_rigs[0], launcher.get_rig_model())\n        launcher.set_rig(rig)\n        return rig\n    else:\n        while True:\n            try:\n                path = self.ui_helper.prompt_pick_from_list(available_rigs, prompt=\"Choose a rig:\")\n                if not isinstance(path, str):\n                    raise ValueError(\"Invalid choice.\")\n                rig = model_from_json_file(path, launcher.get_rig_model())\n                logger.info(\"Using %s.\", path)\n                launcher.set_rig(rig)\n                return rig\n            except pydantic.ValidationError as e:\n                logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n            except ValueError as e:\n                logger.info(\"Invalid choice. Try again. %s\", e)\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.pick_session","title":"pick_session","text":"<pre><code>pick_session(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TSession\n</code></pre> <p>Prompts the user to select or create a session configuration.</p> <p>Collects experimenter information, subject selection, and session notes to create a new session configuration with appropriate metadata.</p> <p>Returns:</p> Name Type Description <code>TSession</code> <code>TSession</code> <p>The created or selected session configuration.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_session(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TSession:\n    \"\"\"\n    Prompts the user to select or create a session configuration.\n\n    Collects experimenter information, subject selection, and session notes\n    to create a new session configuration with appropriate metadata.\n\n    Returns:\n        TSession: The created or selected session configuration.\n    \"\"\"\n    if (session := launcher.get_session()) is not None:\n        logger.info(\"Session already set in launcher. Using existing session.\")\n        return session\n\n    experimenter = self.prompt_experimenter(strict=True)\n    if launcher.subject is not None:\n        logger.info(\"Subject provided via CLABE: %s\", launcher.subject)\n        subject = launcher.subject\n    else:\n        subject = self.choose_subject(self.subject_dir)\n        launcher.subject = subject\n\n        if not (self.subject_dir / subject).exists():\n            logger.info(\"Directory for subject %s does not exist. Creating a new one.\", subject)\n            os.makedirs(self.subject_dir / subject)\n\n    notes = self.ui_helper.prompt_text(\"Enter notes: \")\n    session = launcher.get_session_model()(\n        experiment=\"\",  # Will be set later\n        root_path=str(Path(launcher.settings.data_dir).resolve() / subject),\n        subject=subject,\n        notes=notes,\n        experimenter=experimenter if experimenter is not None else [],\n        commit_hash=launcher.repository.head.commit.hexsha,\n        allow_dirty_repo=launcher.settings.debug_mode or launcher.settings.allow_dirty,\n        skip_hardware_validation=launcher.settings.skip_hardware_validation,\n        experiment_version=\"\",  # Will be set later\n    )\n    launcher.set_session(session)\n    return session\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.pick_task_logic","title":"pick_task_logic","text":"<pre><code>pick_task_logic(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TTaskLogic\n</code></pre> <p>Prompts the user to select or create a task logic configuration.</p> <p>Attempts to load task logic in the following order: 1. From CLI if already set 2. From subject-specific folder 3. From user selection in task logic library</p> <p>Returns:</p> Name Type Description <code>TTaskLogic</code> <code>TTaskLogic</code> <p>The created or selected task logic configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_task_logic(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TTaskLogic:\n    \"\"\"\n    Prompts the user to select or create a task logic configuration.\n\n    Attempts to load task logic in the following order:\n    1. From CLI if already set\n    2. From subject-specific folder\n    3. From user selection in task logic library\n\n    Returns:\n        TTaskLogic: The created or selected task logic configuration.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (task_logic := launcher.get_task_logic()) is not None:\n        logger.info(\"Task logic already set in launcher. Using existing task logic.\")\n        self._sync_session_metadata(launcher)\n        return task_logic\n\n    # Else, we check inside the subject folder for an existing task file\n    try:\n        if launcher.subject is None:\n            logger.error(\"No subject set in launcher. Cannot load task logic.\")\n            raise ValueError(\"No subject set in launcher.\")\n        f = self.subject_dir / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n        logger.info(\"Attempting to load task logic from subject folder: %s\", f)\n        task_logic = model_from_json_file(f, launcher.get_task_logic_model())\n    except (ValueError, FileNotFoundError, pydantic.ValidationError) as e:\n        logger.warning(\"Failed to find a valid task logic file. %s\", e)\n    else:\n        logger.info(\"Found a valid task logic file in subject folder!\")\n        _is_manual = not self.ui_helper.prompt_yes_no_question(\"Would you like to use this task logic?\")\n        if not _is_manual:\n            if task_logic is not None:\n                launcher.set_task_logic(task_logic)\n                return task_logic\n            else:\n                logger.error(\"No valid task logic file found in subject folder.\")\n                raise ValueError(\"No valid task logic file found.\")\n        else:\n            task_logic = None\n\n    # If not found, we prompt the user to choose/enter a task logic file\n    while task_logic is None:\n        try:\n            _path = Path(os.path.join(self.config_library_dir, self.task_logic_dir))\n            available_files = glob.glob(os.path.join(_path, \"*.json\"))\n            if len(available_files) == 0:\n                break\n            path = self.ui_helper.prompt_pick_from_list(available_files, prompt=\"Choose a task logic:\")\n            if not isinstance(path, str):\n                raise ValueError(\"Invalid choice.\")\n            if not os.path.isfile(path):\n                raise FileNotFoundError(f\"File not found: {path}\")\n            task_logic = model_from_json_file(path, launcher.get_task_logic_model())\n            logger.info(\"User entered: %s.\", path)\n        except pydantic.ValidationError as e:\n            logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n        except (ValueError, FileNotFoundError) as e:\n            logger.info(\"Invalid choice. Try again. %s\", e)\n    if task_logic is None:\n        logger.error(\"No task logic file found.\")\n        raise ValueError(\"No task logic file found.\")\n\n    launcher.set_task_logic(task_logic)\n    self._sync_session_metadata(launcher)\n    return task_logic\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.choose_subject","title":"choose_subject","text":"<pre><code>choose_subject(directory: str | PathLike) -&gt; str\n</code></pre> <p>Prompts the user to select or manually enter a subject name.</p> <p>Allows the user to either type a new subject name or select from existing subject directories.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | PathLike</code> <p>Path to the directory containing subject folders</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The selected or entered subject name.</p> Example <pre><code># Choose a subject from the subjects directory\nsubject = picker.choose_subject(\"Subjects\")\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def choose_subject(self, directory: str | os.PathLike) -&gt; str:\n    \"\"\"\n    Prompts the user to select or manually enter a subject name.\n\n    Allows the user to either type a new subject name or select from\n    existing subject directories.\n\n    Args:\n        directory: Path to the directory containing subject folders\n\n    Returns:\n        str: The selected or entered subject name.\n\n    Example:\n        ```python\n        # Choose a subject from the subjects directory\n        subject = picker.choose_subject(\"Subjects\")\n        ```\n    \"\"\"\n    subject = None\n    while subject is None:\n        subject = self.ui_helper.input(\"Enter subject name: \")\n        if subject == \"\":\n            subject = self.ui_helper.prompt_pick_from_list(\n                [\n                    os.path.basename(folder)\n                    for folder in os.listdir(directory)\n                    if os.path.isdir(os.path.join(directory, folder))\n                ],\n                prompt=\"Choose a subject:\",\n                allow_0_as_none=True,\n            )\n        else:\n            return subject\n\n    return subject\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.prompt_experimenter","title":"prompt_experimenter","text":"<pre><code>prompt_experimenter(\n    strict: bool = True,\n) -&gt; Optional[List[str]]\n</code></pre> <p>Prompts the user to enter the experimenter's name(s).</p> <p>Accepts multiple experimenter names separated by commas or spaces. Validates names using the configured validator function if provided.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to enforce non-empty input</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: List of experimenter names.</p> Example <pre><code># Prompt for experimenter with validation\nnames = picker.prompt_experimenter(strict=True)\nprint(\"Experimenters:\", names)\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def prompt_experimenter(self, strict: bool = True) -&gt; Optional[List[str]]:\n    \"\"\"\n    Prompts the user to enter the experimenter's name(s).\n\n    Accepts multiple experimenter names separated by commas or spaces.\n    Validates names using the configured validator function if provided.\n\n    Args:\n        strict: Whether to enforce non-empty input\n\n    Returns:\n        Optional[List[str]]: List of experimenter names.\n\n    Example:\n        ```python\n        # Prompt for experimenter with validation\n        names = picker.prompt_experimenter(strict=True)\n        print(\"Experimenters:\", names)\n        ```\n    \"\"\"\n    experimenter: Optional[List[str]] = None\n    while experimenter is None:\n        _user_input = self.ui_helper.prompt_text(\"Experimenter name: \")\n        experimenter = _user_input.replace(\",\", \" \").split()\n        if strict &amp; (len(experimenter) == 0):\n            logger.info(\"Experimenter name is not valid. Try again.\")\n            experimenter = None\n        else:\n            if self._experimenter_validator:\n                for name in experimenter:\n                    if not self._experimenter_validator(name):\n                        logger.warning(\"Experimenter name: %s, is not valid. Try again\", name)\n                        experimenter = None\n                        break\n    return experimenter\n</code></pre>"},{"location":"api/pickers/dataverse/#clabe.pickers.dataverse.DataversePicker.dump_model","title":"dump_model","text":"<pre><code>dump_model(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[\n        AindBehaviorRigModel,\n        AindBehaviorTaskLogicModel,\n        TrainerState,\n    ],\n) -&gt; Optional[Path]\n</code></pre> <p>Saves the provided model to the appropriate configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>launcher</code> <code>Launcher[TRig, TSession, TTaskLogic]</code> <p>The launcher instance managing the experiment.</p> required <code>model</code> <code>Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState]</code> <p>The model instance to save.</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Optional[Path]: The path to the saved model file, or None if not saved.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def dump_model(\n    self,\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState],\n) -&gt; Optional[Path]:\n    \"\"\"\n    Saves the provided model to the appropriate configuration file.\n\n    Args:\n        launcher: The launcher instance managing the experiment.\n        model: The model instance to save.\n\n    Returns:\n        Optional[Path]: The path to the saved model file, or None if not saved.\n    \"\"\"\n\n    path: Path\n    if isinstance(model, AindBehaviorRigModel):\n        path = self.rig_dir / (\"rig.json\")\n    elif isinstance(model, AindBehaviorTaskLogicModel):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump task logic.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n    elif isinstance(model, TrainerState):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump trainer state.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TRAINER_STATE.value + \".json\")\n    else:\n        raise ValueError(\"Model type not supported for dumping.\")\n\n    os.makedirs(path.parent, exist_ok=True)\n    if path.exists():\n        overwrite = self.ui_helper.prompt_yes_no_question(f\"File {path} already exists. Overwrite?\")\n        if not overwrite:\n            logger.info(\"User chose not to overwrite the existing file: %s\", path)\n            return None\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(model.model_dump_json(indent=2))\n        logger.info(\"Saved model to %s\", path)\n    return path\n</code></pre>"},{"location":"api/pickers/default_behavior/","title":"pickers.default_behavior","text":""},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPickerSettings","title":"DefaultBehaviorPickerSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the default behavior picker.</p> <p>Attributes:</p> Name Type Description <code>config_library_dir</code> <code>PathLike</code> <p>The directory where configuration files are stored.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPickerSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker","title":"DefaultBehaviorPicker","text":"<pre><code>DefaultBehaviorPicker(\n    *,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[UiHelper] = None,\n    experimenter_validator: Optional[\n        Callable[[str], bool]\n    ] = validate_aind_username,\n)\n</code></pre> <p>               Bases: <code>Generic[TRig, TSession, TTaskLogic]</code></p> <p>A picker class for selecting rig, session, and task logic configurations for behavior experiments.</p> <p>This class provides methods to initialize directories, pick configurations, and prompt user inputs for various components of the experiment setup. It manages the configuration library structure and user interactions for selecting experiment parameters.</p> <p>Attributes:</p> Name Type Description <code>RIG_SUFFIX</code> <code>str</code> <p>Directory suffix for rig configurations</p> <code>SUBJECT_SUFFIX</code> <code>str</code> <p>Directory suffix for subject configurations</p> <code>TASK_LOGIC_SUFFIX</code> <code>str</code> <p>Directory suffix for task logic configurations</p> Example <pre><code># Create settings for the picker\nsettings = DefaultBehaviorPickerSettings(config_library_dir=\"config_dir\")\n\n# Create a default behavior picker\npicker = DefaultBehaviorPicker(\n    launcher=some_launcher_instance,\n    settings=settings,\n)\n# Initialize and pick configurations\npicker.initialize()\nrig = picker.pick_rig()\nsession = picker.pick_session()\ntask_logic = picker.pick_task_logic()\n</code></pre> <p>Initializes the DefaultBehaviorPicker.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>DefaultBehaviorPickerSettings</code> <p>Settings containing configuration including config_library_dir. By default, attempts to rely on DefaultBehaviorPickerSettings to automatic loading from yaml files.</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>Helper for user interface interactions. If None, must be registered later using register_ui_helper().</p> <code>None</code> <code>experimenter_validator</code> <code>Optional[Callable[[str], bool]]</code> <p>Function to validate the experimenter's username. If None, no validation is performed</p> <code>validate_aind_username</code> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def __init__(\n    self,\n    *,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[ui.UiHelper] = None,\n    experimenter_validator: Optional[Callable[[str], bool]] = validate_aind_username,\n):\n    \"\"\"\n    Initializes the DefaultBehaviorPicker.\n\n    Args:\n        settings: Settings containing configuration including config_library_dir. By default, attempts to rely on DefaultBehaviorPickerSettings to automatic loading from yaml files.\n        ui_helper: Helper for user interface interactions. If None, must be registered later using register_ui_helper().\n        experimenter_validator: Function to validate the experimenter's username. If None, no validation is performed\n    \"\"\"\n    self._ui_helper = ui_helper\n    self._launcher: Launcher[TRig, TSession, TTaskLogic]\n    self._settings = settings\n    self._experimenter_validator = experimenter_validator\n    self._trainer_state: Optional[TrainerState] = None\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.has_ui_helper","title":"has_ui_helper  <code>property</code>","text":"<pre><code>has_ui_helper: bool\n</code></pre> <p>Checks if a UI helper is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a UI helper is registered, False otherwise</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.ui_helper","title":"ui_helper  <code>property</code>","text":"<pre><code>ui_helper: UiHelper\n</code></pre> <p>Retrieves the registered UI helper.</p> <p>Returns:</p> Name Type Description <code>DefaultUIHelper</code> <code>UiHelper</code> <p>The registered UI helper</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no UI helper is registered</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.trainer_state","title":"trainer_state  <code>property</code>","text":"<pre><code>trainer_state: TrainerState\n</code></pre> <p>Returns the current trainer state.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The current trainer state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the trainer state is not set.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.config_library_dir","title":"config_library_dir  <code>property</code>","text":"<pre><code>config_library_dir: Path\n</code></pre> <p>Returns the path to the configuration library directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The configuration library directory.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.rig_dir","title":"rig_dir  <code>property</code>","text":"<pre><code>rig_dir: Path\n</code></pre> <p>Returns the path to the rig configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The rig configuration directory.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.subject_dir","title":"subject_dir  <code>property</code>","text":"<pre><code>subject_dir: Path\n</code></pre> <p>Returns the path to the subject configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The subject configuration directory.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.task_logic_dir","title":"task_logic_dir  <code>property</code>","text":"<pre><code>task_logic_dir: Path\n</code></pre> <p>Returns the path to the task logic configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The task logic configuration directory.</p>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.register_ui_helper","title":"register_ui_helper","text":"<pre><code>register_ui_helper(ui_helper: UiHelper) -&gt; Self\n</code></pre> <p>Registers a UI helper with the picker.</p> <p>Associates a UI helper instance with this picker for user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>ui_helper</code> <code>UiHelper</code> <p>The UI helper to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The picker instance for method chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a UI helper is already registered</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def register_ui_helper(self, ui_helper: ui.UiHelper) -&gt; Self:\n    \"\"\"\n    Registers a UI helper with the picker.\n\n    Associates a UI helper instance with this picker for user interactions.\n\n    Args:\n        ui_helper: The UI helper to register\n\n    Returns:\n        Self: The picker instance for method chaining\n\n    Raises:\n        ValueError: If a UI helper is already registered\n    \"\"\"\n    if self._ui_helper is None:\n        self._ui_helper = ui_helper\n    else:\n        raise ValueError(\"UI Helper is already registered\")\n    return self\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.initialize","title":"initialize","text":"<pre><code>initialize(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; None\n</code></pre> <p>Initializes the picker by creating required directories if needed.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def initialize(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; None:\n    \"\"\"\n    Initializes the picker by creating required directories if needed.\n    \"\"\"\n    self._launcher = launcher\n    self._ui_helper = launcher.ui_helper\n    self._ensure_directories(launcher)\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.pick_rig","title":"pick_rig","text":"<pre><code>pick_rig(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TRig\n</code></pre> <p>Prompts the user to select a rig configuration file.</p> <p>Searches for available rig configuration files and either automatically selects a single file or prompts the user to choose from multiple options.</p> <p>Returns:</p> Name Type Description <code>TRig</code> <code>TRig</code> <p>The selected rig configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rig configuration files are found or an invalid choice is made.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_rig(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TRig:\n    \"\"\"\n    Prompts the user to select a rig configuration file.\n\n    Searches for available rig configuration files and either automatically\n    selects a single file or prompts the user to choose from multiple options.\n\n    Returns:\n        TRig: The selected rig configuration.\n\n    Raises:\n        ValueError: If no rig configuration files are found or an invalid choice is made.\n    \"\"\"\n    rig = launcher.get_rig()\n    if rig is not None:\n        logger.info(\"Rig already set in launcher. Using existing rig.\")\n        return rig\n    available_rigs = glob.glob(os.path.join(self.rig_dir, \"*.json\"))\n    if len(available_rigs) == 0:\n        logger.error(\"No rig config files found.\")\n        raise ValueError(\"No rig config files found.\")\n    elif len(available_rigs) == 1:\n        logger.info(\"Found a single rig config file. Using %s.\", {available_rigs[0]})\n        rig = model_from_json_file(available_rigs[0], launcher.get_rig_model())\n        launcher.set_rig(rig)\n        return rig\n    else:\n        while True:\n            try:\n                path = self.ui_helper.prompt_pick_from_list(available_rigs, prompt=\"Choose a rig:\")\n                if not isinstance(path, str):\n                    raise ValueError(\"Invalid choice.\")\n                rig = model_from_json_file(path, launcher.get_rig_model())\n                logger.info(\"Using %s.\", path)\n                launcher.set_rig(rig)\n                return rig\n            except pydantic.ValidationError as e:\n                logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n            except ValueError as e:\n                logger.info(\"Invalid choice. Try again. %s\", e)\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.pick_session","title":"pick_session","text":"<pre><code>pick_session(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TSession\n</code></pre> <p>Prompts the user to select or create a session configuration.</p> <p>Collects experimenter information, subject selection, and session notes to create a new session configuration with appropriate metadata.</p> <p>Returns:</p> Name Type Description <code>TSession</code> <code>TSession</code> <p>The created or selected session configuration.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_session(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TSession:\n    \"\"\"\n    Prompts the user to select or create a session configuration.\n\n    Collects experimenter information, subject selection, and session notes\n    to create a new session configuration with appropriate metadata.\n\n    Returns:\n        TSession: The created or selected session configuration.\n    \"\"\"\n    if (session := launcher.get_session()) is not None:\n        logger.info(\"Session already set in launcher. Using existing session.\")\n        return session\n\n    experimenter = self.prompt_experimenter(strict=True)\n    if launcher.subject is not None:\n        logger.info(\"Subject provided via CLABE: %s\", launcher.subject)\n        subject = launcher.subject\n    else:\n        subject = self.choose_subject(self.subject_dir)\n        launcher.subject = subject\n\n        if not (self.subject_dir / subject).exists():\n            logger.info(\"Directory for subject %s does not exist. Creating a new one.\", subject)\n            os.makedirs(self.subject_dir / subject)\n\n    notes = self.ui_helper.prompt_text(\"Enter notes: \")\n    session = launcher.get_session_model()(\n        experiment=\"\",  # Will be set later\n        root_path=str(Path(launcher.settings.data_dir).resolve() / subject),\n        subject=subject,\n        notes=notes,\n        experimenter=experimenter if experimenter is not None else [],\n        commit_hash=launcher.repository.head.commit.hexsha,\n        allow_dirty_repo=launcher.settings.debug_mode or launcher.settings.allow_dirty,\n        skip_hardware_validation=launcher.settings.skip_hardware_validation,\n        experiment_version=\"\",  # Will be set later\n    )\n    launcher.set_session(session)\n    return session\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.pick_task_logic","title":"pick_task_logic","text":"<pre><code>pick_task_logic(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TTaskLogic\n</code></pre> <p>Prompts the user to select or create a task logic configuration.</p> <p>Attempts to load task logic in the following order: 1. From CLI if already set 2. From subject-specific folder 3. From user selection in task logic library</p> <p>Returns:</p> Name Type Description <code>TTaskLogic</code> <code>TTaskLogic</code> <p>The created or selected task logic configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_task_logic(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TTaskLogic:\n    \"\"\"\n    Prompts the user to select or create a task logic configuration.\n\n    Attempts to load task logic in the following order:\n    1. From CLI if already set\n    2. From subject-specific folder\n    3. From user selection in task logic library\n\n    Returns:\n        TTaskLogic: The created or selected task logic configuration.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (task_logic := launcher.get_task_logic()) is not None:\n        logger.info(\"Task logic already set in launcher. Using existing task logic.\")\n        self._sync_session_metadata(launcher)\n        return task_logic\n\n    # Else, we check inside the subject folder for an existing task file\n    try:\n        if launcher.subject is None:\n            logger.error(\"No subject set in launcher. Cannot load task logic.\")\n            raise ValueError(\"No subject set in launcher.\")\n        f = self.subject_dir / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n        logger.info(\"Attempting to load task logic from subject folder: %s\", f)\n        task_logic = model_from_json_file(f, launcher.get_task_logic_model())\n    except (ValueError, FileNotFoundError, pydantic.ValidationError) as e:\n        logger.warning(\"Failed to find a valid task logic file. %s\", e)\n    else:\n        logger.info(\"Found a valid task logic file in subject folder!\")\n        _is_manual = not self.ui_helper.prompt_yes_no_question(\"Would you like to use this task logic?\")\n        if not _is_manual:\n            if task_logic is not None:\n                launcher.set_task_logic(task_logic)\n                return task_logic\n            else:\n                logger.error(\"No valid task logic file found in subject folder.\")\n                raise ValueError(\"No valid task logic file found.\")\n        else:\n            task_logic = None\n\n    # If not found, we prompt the user to choose/enter a task logic file\n    while task_logic is None:\n        try:\n            _path = Path(os.path.join(self.config_library_dir, self.task_logic_dir))\n            available_files = glob.glob(os.path.join(_path, \"*.json\"))\n            if len(available_files) == 0:\n                break\n            path = self.ui_helper.prompt_pick_from_list(available_files, prompt=\"Choose a task logic:\")\n            if not isinstance(path, str):\n                raise ValueError(\"Invalid choice.\")\n            if not os.path.isfile(path):\n                raise FileNotFoundError(f\"File not found: {path}\")\n            task_logic = model_from_json_file(path, launcher.get_task_logic_model())\n            logger.info(\"User entered: %s.\", path)\n        except pydantic.ValidationError as e:\n            logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n        except (ValueError, FileNotFoundError) as e:\n            logger.info(\"Invalid choice. Try again. %s\", e)\n    if task_logic is None:\n        logger.error(\"No task logic file found.\")\n        raise ValueError(\"No task logic file found.\")\n\n    launcher.set_task_logic(task_logic)\n    self._sync_session_metadata(launcher)\n    return task_logic\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.pick_trainer_state","title":"pick_trainer_state","text":"<pre><code>pick_trainer_state(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TrainerState\n</code></pre> <p>Prompts the user to select or create a trainer state configuration.</p> <p>Attempts to load trainer state in the following order: 1. If task_logic already exists in launcher, will return an empty TrainerState 2. From subject-specific folder</p> <p>It will launcher.set_task_logic if the deserialized TrainerState is valid.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The deserialized TrainerState object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_trainer_state(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TrainerState:\n    \"\"\"\n    Prompts the user to select or create a trainer state configuration.\n\n    Attempts to load trainer state in the following order:\n    1. If task_logic already exists in launcher, will return an empty TrainerState\n    2. From subject-specific folder\n\n    It will launcher.set_task_logic if the deserialized TrainerState is valid.\n\n    Returns:\n        TrainerState: The deserialized TrainerState object.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (launcher.get_task_logic()) is not None:\n        logger.info(\"Task logic already set in launcher. Cannot inject a trainer state.\")\n        self._trainer_state = TrainerState(curriculum=None, stage=None, is_on_curriculum=False)\n    else:\n        try:\n            if launcher.subject is None:\n                logger.error(\"No subject set in launcher. Cannot load trainer state.\")\n                raise ValueError(\"No subject set in launcher.\")\n            f = self.subject_dir / launcher.subject / (ByAnimalFiles.TRAINER_STATE.value + \".json\")\n            logger.info(\"Attempting to load trainer state from subject folder: %s\", f)\n            trainer_state = model_from_json_file(f, TrainerState)\n            if trainer_state.stage is None:\n                raise ValueError(\"Trainer state stage is None, cannot use this trainer state.\")\n        except (ValueError, FileNotFoundError, pydantic.ValidationError) as e:\n            logger.error(\"Failed to find a valid task logic file. %s\", e)\n            raise\n        else:\n            self._trainer_state = trainer_state\n            launcher.set_task_logic(trainer_state.stage.task)\n\n    if not self._trainer_state.is_on_curriculum:\n        logging.warning(\"Deserialized TrainerState is NOT on curriculum.\")\n\n    self._sync_session_metadata(launcher)\n    return self.trainer_state\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.choose_subject","title":"choose_subject","text":"<pre><code>choose_subject(directory: str | PathLike) -&gt; str\n</code></pre> <p>Prompts the user to select or manually enter a subject name.</p> <p>Allows the user to either type a new subject name or select from existing subject directories.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | PathLike</code> <p>Path to the directory containing subject folders</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The selected or entered subject name.</p> Example <pre><code># Choose a subject from the subjects directory\nsubject = picker.choose_subject(\"Subjects\")\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def choose_subject(self, directory: str | os.PathLike) -&gt; str:\n    \"\"\"\n    Prompts the user to select or manually enter a subject name.\n\n    Allows the user to either type a new subject name or select from\n    existing subject directories.\n\n    Args:\n        directory: Path to the directory containing subject folders\n\n    Returns:\n        str: The selected or entered subject name.\n\n    Example:\n        ```python\n        # Choose a subject from the subjects directory\n        subject = picker.choose_subject(\"Subjects\")\n        ```\n    \"\"\"\n    subject = None\n    while subject is None:\n        subject = self.ui_helper.input(\"Enter subject name: \")\n        if subject == \"\":\n            subject = self.ui_helper.prompt_pick_from_list(\n                [\n                    os.path.basename(folder)\n                    for folder in os.listdir(directory)\n                    if os.path.isdir(os.path.join(directory, folder))\n                ],\n                prompt=\"Choose a subject:\",\n                allow_0_as_none=True,\n            )\n        else:\n            return subject\n\n    return subject\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.prompt_experimenter","title":"prompt_experimenter","text":"<pre><code>prompt_experimenter(\n    strict: bool = True,\n) -&gt; Optional[List[str]]\n</code></pre> <p>Prompts the user to enter the experimenter's name(s).</p> <p>Accepts multiple experimenter names separated by commas or spaces. Validates names using the configured validator function if provided.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to enforce non-empty input</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: List of experimenter names.</p> Example <pre><code># Prompt for experimenter with validation\nnames = picker.prompt_experimenter(strict=True)\nprint(\"Experimenters:\", names)\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def prompt_experimenter(self, strict: bool = True) -&gt; Optional[List[str]]:\n    \"\"\"\n    Prompts the user to enter the experimenter's name(s).\n\n    Accepts multiple experimenter names separated by commas or spaces.\n    Validates names using the configured validator function if provided.\n\n    Args:\n        strict: Whether to enforce non-empty input\n\n    Returns:\n        Optional[List[str]]: List of experimenter names.\n\n    Example:\n        ```python\n        # Prompt for experimenter with validation\n        names = picker.prompt_experimenter(strict=True)\n        print(\"Experimenters:\", names)\n        ```\n    \"\"\"\n    experimenter: Optional[List[str]] = None\n    while experimenter is None:\n        _user_input = self.ui_helper.prompt_text(\"Experimenter name: \")\n        experimenter = _user_input.replace(\",\", \" \").split()\n        if strict &amp; (len(experimenter) == 0):\n            logger.info(\"Experimenter name is not valid. Try again.\")\n            experimenter = None\n        else:\n            if self._experimenter_validator:\n                for name in experimenter:\n                    if not self._experimenter_validator(name):\n                        logger.warning(\"Experimenter name: %s, is not valid. Try again\", name)\n                        experimenter = None\n                        break\n    return experimenter\n</code></pre>"},{"location":"api/pickers/default_behavior/#clabe.pickers.default_behavior.DefaultBehaviorPicker.dump_model","title":"dump_model","text":"<pre><code>dump_model(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[\n        AindBehaviorRigModel,\n        AindBehaviorTaskLogicModel,\n        TrainerState,\n    ],\n) -&gt; Optional[Path]\n</code></pre> <p>Saves the provided model to the appropriate configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>launcher</code> <code>Launcher[TRig, TSession, TTaskLogic]</code> <p>The launcher instance managing the experiment.</p> required <code>model</code> <code>Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState]</code> <p>The model instance to save.</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Optional[Path]: The path to the saved model file, or None if not saved.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def dump_model(\n    self,\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState],\n) -&gt; Optional[Path]:\n    \"\"\"\n    Saves the provided model to the appropriate configuration file.\n\n    Args:\n        launcher: The launcher instance managing the experiment.\n        model: The model instance to save.\n\n    Returns:\n        Optional[Path]: The path to the saved model file, or None if not saved.\n    \"\"\"\n\n    path: Path\n    if isinstance(model, AindBehaviorRigModel):\n        path = self.rig_dir / (\"rig.json\")\n    elif isinstance(model, AindBehaviorTaskLogicModel):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump task logic.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n    elif isinstance(model, TrainerState):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump trainer state.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TRAINER_STATE.value + \".json\")\n    else:\n        raise ValueError(\"Model type not supported for dumping.\")\n\n    os.makedirs(path.parent, exist_ok=True)\n    if path.exists():\n        overwrite = self.ui_helper.prompt_yes_no_question(f\"File {path} already exists. Overwrite?\")\n        if not overwrite:\n            logger.info(\"User chose not to overwrite the existing file: %s\", path)\n            return None\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(model.model_dump_json(indent=2))\n        logger.info(\"Saved model to %s\", path)\n    return path\n</code></pre>"},{"location":"api/pickers/pickers/","title":"pickers","text":""},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker","title":"DefaultBehaviorPicker","text":"<pre><code>DefaultBehaviorPicker(\n    *,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[UiHelper] = None,\n    experimenter_validator: Optional[\n        Callable[[str], bool]\n    ] = validate_aind_username,\n)\n</code></pre> <p>               Bases: <code>Generic[TRig, TSession, TTaskLogic]</code></p> <p>A picker class for selecting rig, session, and task logic configurations for behavior experiments.</p> <p>This class provides methods to initialize directories, pick configurations, and prompt user inputs for various components of the experiment setup. It manages the configuration library structure and user interactions for selecting experiment parameters.</p> <p>Attributes:</p> Name Type Description <code>RIG_SUFFIX</code> <code>str</code> <p>Directory suffix for rig configurations</p> <code>SUBJECT_SUFFIX</code> <code>str</code> <p>Directory suffix for subject configurations</p> <code>TASK_LOGIC_SUFFIX</code> <code>str</code> <p>Directory suffix for task logic configurations</p> Example <pre><code># Create settings for the picker\nsettings = DefaultBehaviorPickerSettings(config_library_dir=\"config_dir\")\n\n# Create a default behavior picker\npicker = DefaultBehaviorPicker(\n    launcher=some_launcher_instance,\n    settings=settings,\n)\n# Initialize and pick configurations\npicker.initialize()\nrig = picker.pick_rig()\nsession = picker.pick_session()\ntask_logic = picker.pick_task_logic()\n</code></pre> <p>Initializes the DefaultBehaviorPicker.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>DefaultBehaviorPickerSettings</code> <p>Settings containing configuration including config_library_dir. By default, attempts to rely on DefaultBehaviorPickerSettings to automatic loading from yaml files.</p> required <code>ui_helper</code> <code>Optional[UiHelper]</code> <p>Helper for user interface interactions. If None, must be registered later using register_ui_helper().</p> <code>None</code> <code>experimenter_validator</code> <code>Optional[Callable[[str], bool]]</code> <p>Function to validate the experimenter's username. If None, no validation is performed</p> <code>validate_aind_username</code> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def __init__(\n    self,\n    *,\n    settings: DefaultBehaviorPickerSettings,\n    ui_helper: Optional[ui.UiHelper] = None,\n    experimenter_validator: Optional[Callable[[str], bool]] = validate_aind_username,\n):\n    \"\"\"\n    Initializes the DefaultBehaviorPicker.\n\n    Args:\n        settings: Settings containing configuration including config_library_dir. By default, attempts to rely on DefaultBehaviorPickerSettings to automatic loading from yaml files.\n        ui_helper: Helper for user interface interactions. If None, must be registered later using register_ui_helper().\n        experimenter_validator: Function to validate the experimenter's username. If None, no validation is performed\n    \"\"\"\n    self._ui_helper = ui_helper\n    self._launcher: Launcher[TRig, TSession, TTaskLogic]\n    self._settings = settings\n    self._experimenter_validator = experimenter_validator\n    self._trainer_state: Optional[TrainerState] = None\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.has_ui_helper","title":"has_ui_helper  <code>property</code>","text":"<pre><code>has_ui_helper: bool\n</code></pre> <p>Checks if a UI helper is registered.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if a UI helper is registered, False otherwise</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.ui_helper","title":"ui_helper  <code>property</code>","text":"<pre><code>ui_helper: UiHelper\n</code></pre> <p>Retrieves the registered UI helper.</p> <p>Returns:</p> Name Type Description <code>DefaultUIHelper</code> <code>UiHelper</code> <p>The registered UI helper</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no UI helper is registered</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.trainer_state","title":"trainer_state  <code>property</code>","text":"<pre><code>trainer_state: TrainerState\n</code></pre> <p>Returns the current trainer state.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The current trainer state.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the trainer state is not set.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.config_library_dir","title":"config_library_dir  <code>property</code>","text":"<pre><code>config_library_dir: Path\n</code></pre> <p>Returns the path to the configuration library directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The configuration library directory.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.rig_dir","title":"rig_dir  <code>property</code>","text":"<pre><code>rig_dir: Path\n</code></pre> <p>Returns the path to the rig configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The rig configuration directory.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.subject_dir","title":"subject_dir  <code>property</code>","text":"<pre><code>subject_dir: Path\n</code></pre> <p>Returns the path to the subject configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The subject configuration directory.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.task_logic_dir","title":"task_logic_dir  <code>property</code>","text":"<pre><code>task_logic_dir: Path\n</code></pre> <p>Returns the path to the task logic configuration directory.</p> <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The task logic configuration directory.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.register_ui_helper","title":"register_ui_helper","text":"<pre><code>register_ui_helper(ui_helper: UiHelper) -&gt; Self\n</code></pre> <p>Registers a UI helper with the picker.</p> <p>Associates a UI helper instance with this picker for user interactions.</p> <p>Parameters:</p> Name Type Description Default <code>ui_helper</code> <code>UiHelper</code> <p>The UI helper to register</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>The picker instance for method chaining</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a UI helper is already registered</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def register_ui_helper(self, ui_helper: ui.UiHelper) -&gt; Self:\n    \"\"\"\n    Registers a UI helper with the picker.\n\n    Associates a UI helper instance with this picker for user interactions.\n\n    Args:\n        ui_helper: The UI helper to register\n\n    Returns:\n        Self: The picker instance for method chaining\n\n    Raises:\n        ValueError: If a UI helper is already registered\n    \"\"\"\n    if self._ui_helper is None:\n        self._ui_helper = ui_helper\n    else:\n        raise ValueError(\"UI Helper is already registered\")\n    return self\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.initialize","title":"initialize","text":"<pre><code>initialize(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; None\n</code></pre> <p>Initializes the picker by creating required directories if needed.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def initialize(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; None:\n    \"\"\"\n    Initializes the picker by creating required directories if needed.\n    \"\"\"\n    self._launcher = launcher\n    self._ui_helper = launcher.ui_helper\n    self._ensure_directories(launcher)\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.pick_rig","title":"pick_rig","text":"<pre><code>pick_rig(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TRig\n</code></pre> <p>Prompts the user to select a rig configuration file.</p> <p>Searches for available rig configuration files and either automatically selects a single file or prompts the user to choose from multiple options.</p> <p>Returns:</p> Name Type Description <code>TRig</code> <code>TRig</code> <p>The selected rig configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rig configuration files are found or an invalid choice is made.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_rig(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TRig:\n    \"\"\"\n    Prompts the user to select a rig configuration file.\n\n    Searches for available rig configuration files and either automatically\n    selects a single file or prompts the user to choose from multiple options.\n\n    Returns:\n        TRig: The selected rig configuration.\n\n    Raises:\n        ValueError: If no rig configuration files are found or an invalid choice is made.\n    \"\"\"\n    rig = launcher.get_rig()\n    if rig is not None:\n        logger.info(\"Rig already set in launcher. Using existing rig.\")\n        return rig\n    available_rigs = glob.glob(os.path.join(self.rig_dir, \"*.json\"))\n    if len(available_rigs) == 0:\n        logger.error(\"No rig config files found.\")\n        raise ValueError(\"No rig config files found.\")\n    elif len(available_rigs) == 1:\n        logger.info(\"Found a single rig config file. Using %s.\", {available_rigs[0]})\n        rig = model_from_json_file(available_rigs[0], launcher.get_rig_model())\n        launcher.set_rig(rig)\n        return rig\n    else:\n        while True:\n            try:\n                path = self.ui_helper.prompt_pick_from_list(available_rigs, prompt=\"Choose a rig:\")\n                if not isinstance(path, str):\n                    raise ValueError(\"Invalid choice.\")\n                rig = model_from_json_file(path, launcher.get_rig_model())\n                logger.info(\"Using %s.\", path)\n                launcher.set_rig(rig)\n                return rig\n            except pydantic.ValidationError as e:\n                logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n            except ValueError as e:\n                logger.info(\"Invalid choice. Try again. %s\", e)\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.pick_session","title":"pick_session","text":"<pre><code>pick_session(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TSession\n</code></pre> <p>Prompts the user to select or create a session configuration.</p> <p>Collects experimenter information, subject selection, and session notes to create a new session configuration with appropriate metadata.</p> <p>Returns:</p> Name Type Description <code>TSession</code> <code>TSession</code> <p>The created or selected session configuration.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_session(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TSession:\n    \"\"\"\n    Prompts the user to select or create a session configuration.\n\n    Collects experimenter information, subject selection, and session notes\n    to create a new session configuration with appropriate metadata.\n\n    Returns:\n        TSession: The created or selected session configuration.\n    \"\"\"\n    if (session := launcher.get_session()) is not None:\n        logger.info(\"Session already set in launcher. Using existing session.\")\n        return session\n\n    experimenter = self.prompt_experimenter(strict=True)\n    if launcher.subject is not None:\n        logger.info(\"Subject provided via CLABE: %s\", launcher.subject)\n        subject = launcher.subject\n    else:\n        subject = self.choose_subject(self.subject_dir)\n        launcher.subject = subject\n\n        if not (self.subject_dir / subject).exists():\n            logger.info(\"Directory for subject %s does not exist. Creating a new one.\", subject)\n            os.makedirs(self.subject_dir / subject)\n\n    notes = self.ui_helper.prompt_text(\"Enter notes: \")\n    session = launcher.get_session_model()(\n        experiment=\"\",  # Will be set later\n        root_path=str(Path(launcher.settings.data_dir).resolve() / subject),\n        subject=subject,\n        notes=notes,\n        experimenter=experimenter if experimenter is not None else [],\n        commit_hash=launcher.repository.head.commit.hexsha,\n        allow_dirty_repo=launcher.settings.debug_mode or launcher.settings.allow_dirty,\n        skip_hardware_validation=launcher.settings.skip_hardware_validation,\n        experiment_version=\"\",  # Will be set later\n    )\n    launcher.set_session(session)\n    return session\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.pick_task_logic","title":"pick_task_logic","text":"<pre><code>pick_task_logic(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TTaskLogic\n</code></pre> <p>Prompts the user to select or create a task logic configuration.</p> <p>Attempts to load task logic in the following order: 1. From CLI if already set 2. From subject-specific folder 3. From user selection in task logic library</p> <p>Returns:</p> Name Type Description <code>TTaskLogic</code> <code>TTaskLogic</code> <p>The created or selected task logic configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_task_logic(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TTaskLogic:\n    \"\"\"\n    Prompts the user to select or create a task logic configuration.\n\n    Attempts to load task logic in the following order:\n    1. From CLI if already set\n    2. From subject-specific folder\n    3. From user selection in task logic library\n\n    Returns:\n        TTaskLogic: The created or selected task logic configuration.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (task_logic := launcher.get_task_logic()) is not None:\n        logger.info(\"Task logic already set in launcher. Using existing task logic.\")\n        self._sync_session_metadata(launcher)\n        return task_logic\n\n    # Else, we check inside the subject folder for an existing task file\n    try:\n        if launcher.subject is None:\n            logger.error(\"No subject set in launcher. Cannot load task logic.\")\n            raise ValueError(\"No subject set in launcher.\")\n        f = self.subject_dir / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n        logger.info(\"Attempting to load task logic from subject folder: %s\", f)\n        task_logic = model_from_json_file(f, launcher.get_task_logic_model())\n    except (ValueError, FileNotFoundError, pydantic.ValidationError) as e:\n        logger.warning(\"Failed to find a valid task logic file. %s\", e)\n    else:\n        logger.info(\"Found a valid task logic file in subject folder!\")\n        _is_manual = not self.ui_helper.prompt_yes_no_question(\"Would you like to use this task logic?\")\n        if not _is_manual:\n            if task_logic is not None:\n                launcher.set_task_logic(task_logic)\n                return task_logic\n            else:\n                logger.error(\"No valid task logic file found in subject folder.\")\n                raise ValueError(\"No valid task logic file found.\")\n        else:\n            task_logic = None\n\n    # If not found, we prompt the user to choose/enter a task logic file\n    while task_logic is None:\n        try:\n            _path = Path(os.path.join(self.config_library_dir, self.task_logic_dir))\n            available_files = glob.glob(os.path.join(_path, \"*.json\"))\n            if len(available_files) == 0:\n                break\n            path = self.ui_helper.prompt_pick_from_list(available_files, prompt=\"Choose a task logic:\")\n            if not isinstance(path, str):\n                raise ValueError(\"Invalid choice.\")\n            if not os.path.isfile(path):\n                raise FileNotFoundError(f\"File not found: {path}\")\n            task_logic = model_from_json_file(path, launcher.get_task_logic_model())\n            logger.info(\"User entered: %s.\", path)\n        except pydantic.ValidationError as e:\n            logger.error(\"Failed to validate pydantic model. Try again. %s\", e)\n        except (ValueError, FileNotFoundError) as e:\n            logger.info(\"Invalid choice. Try again. %s\", e)\n    if task_logic is None:\n        logger.error(\"No task logic file found.\")\n        raise ValueError(\"No task logic file found.\")\n\n    launcher.set_task_logic(task_logic)\n    self._sync_session_metadata(launcher)\n    return task_logic\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.pick_trainer_state","title":"pick_trainer_state","text":"<pre><code>pick_trainer_state(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n) -&gt; TrainerState\n</code></pre> <p>Prompts the user to select or create a trainer state configuration.</p> <p>Attempts to load trainer state in the following order: 1. If task_logic already exists in launcher, will return an empty TrainerState 2. From subject-specific folder</p> <p>It will launcher.set_task_logic if the deserialized TrainerState is valid.</p> <p>Returns:</p> Name Type Description <code>TrainerState</code> <code>TrainerState</code> <p>The deserialized TrainerState object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid task logic file is found.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def pick_trainer_state(self, launcher: Launcher[TRig, TSession, TTaskLogic]) -&gt; TrainerState:\n    \"\"\"\n    Prompts the user to select or create a trainer state configuration.\n\n    Attempts to load trainer state in the following order:\n    1. If task_logic already exists in launcher, will return an empty TrainerState\n    2. From subject-specific folder\n\n    It will launcher.set_task_logic if the deserialized TrainerState is valid.\n\n    Returns:\n        TrainerState: The deserialized TrainerState object.\n\n    Raises:\n        ValueError: If no valid task logic file is found.\n    \"\"\"\n    if (launcher.get_task_logic()) is not None:\n        logger.info(\"Task logic already set in launcher. Cannot inject a trainer state.\")\n        self._trainer_state = TrainerState(curriculum=None, stage=None, is_on_curriculum=False)\n    else:\n        try:\n            if launcher.subject is None:\n                logger.error(\"No subject set in launcher. Cannot load trainer state.\")\n                raise ValueError(\"No subject set in launcher.\")\n            f = self.subject_dir / launcher.subject / (ByAnimalFiles.TRAINER_STATE.value + \".json\")\n            logger.info(\"Attempting to load trainer state from subject folder: %s\", f)\n            trainer_state = model_from_json_file(f, TrainerState)\n            if trainer_state.stage is None:\n                raise ValueError(\"Trainer state stage is None, cannot use this trainer state.\")\n        except (ValueError, FileNotFoundError, pydantic.ValidationError) as e:\n            logger.error(\"Failed to find a valid task logic file. %s\", e)\n            raise\n        else:\n            self._trainer_state = trainer_state\n            launcher.set_task_logic(trainer_state.stage.task)\n\n    if not self._trainer_state.is_on_curriculum:\n        logging.warning(\"Deserialized TrainerState is NOT on curriculum.\")\n\n    self._sync_session_metadata(launcher)\n    return self.trainer_state\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.choose_subject","title":"choose_subject","text":"<pre><code>choose_subject(directory: str | PathLike) -&gt; str\n</code></pre> <p>Prompts the user to select or manually enter a subject name.</p> <p>Allows the user to either type a new subject name or select from existing subject directories.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | PathLike</code> <p>Path to the directory containing subject folders</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The selected or entered subject name.</p> Example <pre><code># Choose a subject from the subjects directory\nsubject = picker.choose_subject(\"Subjects\")\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def choose_subject(self, directory: str | os.PathLike) -&gt; str:\n    \"\"\"\n    Prompts the user to select or manually enter a subject name.\n\n    Allows the user to either type a new subject name or select from\n    existing subject directories.\n\n    Args:\n        directory: Path to the directory containing subject folders\n\n    Returns:\n        str: The selected or entered subject name.\n\n    Example:\n        ```python\n        # Choose a subject from the subjects directory\n        subject = picker.choose_subject(\"Subjects\")\n        ```\n    \"\"\"\n    subject = None\n    while subject is None:\n        subject = self.ui_helper.input(\"Enter subject name: \")\n        if subject == \"\":\n            subject = self.ui_helper.prompt_pick_from_list(\n                [\n                    os.path.basename(folder)\n                    for folder in os.listdir(directory)\n                    if os.path.isdir(os.path.join(directory, folder))\n                ],\n                prompt=\"Choose a subject:\",\n                allow_0_as_none=True,\n            )\n        else:\n            return subject\n\n    return subject\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.prompt_experimenter","title":"prompt_experimenter","text":"<pre><code>prompt_experimenter(\n    strict: bool = True,\n) -&gt; Optional[List[str]]\n</code></pre> <p>Prompts the user to enter the experimenter's name(s).</p> <p>Accepts multiple experimenter names separated by commas or spaces. Validates names using the configured validator function if provided.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to enforce non-empty input</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[List[str]]</code> <p>Optional[List[str]]: List of experimenter names.</p> Example <pre><code># Prompt for experimenter with validation\nnames = picker.prompt_experimenter(strict=True)\nprint(\"Experimenters:\", names)\n</code></pre> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def prompt_experimenter(self, strict: bool = True) -&gt; Optional[List[str]]:\n    \"\"\"\n    Prompts the user to enter the experimenter's name(s).\n\n    Accepts multiple experimenter names separated by commas or spaces.\n    Validates names using the configured validator function if provided.\n\n    Args:\n        strict: Whether to enforce non-empty input\n\n    Returns:\n        Optional[List[str]]: List of experimenter names.\n\n    Example:\n        ```python\n        # Prompt for experimenter with validation\n        names = picker.prompt_experimenter(strict=True)\n        print(\"Experimenters:\", names)\n        ```\n    \"\"\"\n    experimenter: Optional[List[str]] = None\n    while experimenter is None:\n        _user_input = self.ui_helper.prompt_text(\"Experimenter name: \")\n        experimenter = _user_input.replace(\",\", \" \").split()\n        if strict &amp; (len(experimenter) == 0):\n            logger.info(\"Experimenter name is not valid. Try again.\")\n            experimenter = None\n        else:\n            if self._experimenter_validator:\n                for name in experimenter:\n                    if not self._experimenter_validator(name):\n                        logger.warning(\"Experimenter name: %s, is not valid. Try again\", name)\n                        experimenter = None\n                        break\n    return experimenter\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPicker.dump_model","title":"dump_model","text":"<pre><code>dump_model(\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[\n        AindBehaviorRigModel,\n        AindBehaviorTaskLogicModel,\n        TrainerState,\n    ],\n) -&gt; Optional[Path]\n</code></pre> <p>Saves the provided model to the appropriate configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>launcher</code> <code>Launcher[TRig, TSession, TTaskLogic]</code> <p>The launcher instance managing the experiment.</p> required <code>model</code> <code>Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState]</code> <p>The model instance to save.</p> required <p>Returns:</p> Type Description <code>Optional[Path]</code> <p>Optional[Path]: The path to the saved model file, or None if not saved.</p> Source code in <code>src\\clabe\\pickers\\default_behavior.py</code> <pre><code>def dump_model(\n    self,\n    launcher: Launcher[TRig, TSession, TTaskLogic],\n    model: Union[AindBehaviorRigModel, AindBehaviorTaskLogicModel, TrainerState],\n) -&gt; Optional[Path]:\n    \"\"\"\n    Saves the provided model to the appropriate configuration file.\n\n    Args:\n        launcher: The launcher instance managing the experiment.\n        model: The model instance to save.\n\n    Returns:\n        Optional[Path]: The path to the saved model file, or None if not saved.\n    \"\"\"\n\n    path: Path\n    if isinstance(model, AindBehaviorRigModel):\n        path = self.rig_dir / (\"rig.json\")\n    elif isinstance(model, AindBehaviorTaskLogicModel):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump task logic.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TASK_LOGIC.value + \".json\")\n    elif isinstance(model, TrainerState):\n        if launcher.subject is None:\n            raise ValueError(\"No subject set in launcher. Cannot dump trainer state.\")\n        path = Path(self.subject_dir) / launcher.subject / (ByAnimalFiles.TRAINER_STATE.value + \".json\")\n    else:\n        raise ValueError(\"Model type not supported for dumping.\")\n\n    os.makedirs(path.parent, exist_ok=True)\n    if path.exists():\n        overwrite = self.ui_helper.prompt_yes_no_question(f\"File {path} already exists. Overwrite?\")\n        if not overwrite:\n            logger.info(\"User chose not to overwrite the existing file: %s\", path)\n            return None\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(model.model_dump_json(indent=2))\n        logger.info(\"Saved model to %s\", path)\n    return path\n</code></pre>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPickerSettings","title":"DefaultBehaviorPickerSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the default behavior picker.</p> <p>Attributes:</p> Name Type Description <code>config_library_dir</code> <code>PathLike</code> <p>The directory where configuration files are stored.</p>"},{"location":"api/pickers/pickers/#clabe.pickers.DefaultBehaviorPickerSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/","title":"resource_monitor","text":""},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.ResourceMonitor","title":"ResourceMonitor","text":"<pre><code>ResourceMonitor(\n    *args,\n    constrains: Optional[List[Constraint]] = None,\n    **kwargs,\n)\n</code></pre> <p>               Bases: <code>Service</code></p> <p>A service that monitors and validates resource constraints.</p> <p>This service manages a collection of constraints that can be evaluated to ensure that system resources meet the requirements for experiment execution.</p> <p>Attributes:</p> Name Type Description <code>constraints</code> <code>List[Constraint]</code> <p>A list of constraints to monitor</p> Example <pre><code>from clabe.resource_monitor import available_storage_constraint_factory\n\n# Create monitor with storage constraint\nmonitor = ResourceMonitor()\nstorage_constraint = available_storage_constraint_factory(\n    drive=\"C:\\\", min_bytes=1e9  # 1GB minimum\n)\nmonitor.add_constraint(storage_constraint)\n\n# Validate all constraints\nif monitor.validate():\n    print(\"All constraints satisfied\")\nelse:\n    print(\"Some constraints failed\")\n</code></pre> <p>Initializes the ResourceMonitor.</p> <p>Parameters:</p> Name Type Description Default <code>constrains</code> <code>Optional[List[Constraint]]</code> <p>A list of constraints to initialize with. Defaults to None</p> <code>None</code> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def __init__(\n    self,\n    *args,\n    constrains: Optional[List[Constraint]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"\n    Initializes the ResourceMonitor.\n\n    Args:\n        constrains: A list of constraints to initialize with. Defaults to None\n    \"\"\"\n    self.constraints = constrains or []\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.ResourceMonitor.build_runner","title":"build_runner","text":"<pre><code>build_runner() -&gt; Callable[[Launcher], bool]\n</code></pre> <p>Builds a runner function that evaluates all constraints.</p> <p>Returns:</p> Type Description <code>Callable[[Launcher], bool]</code> <p>A callable that takes a launcher instance and returns True if all constraints are satisfied, False otherwise.</p> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def build_runner(self) -&gt; Callable[[Launcher], bool]:\n    \"\"\"\n    Builds a runner function that evaluates all constraints.\n\n    Returns:\n        A callable that takes a launcher instance and returns True if all constraints are satisfied, False otherwise.\n    \"\"\"\n\n    def _run(launcher: Launcher) -&gt; bool:\n        \"\"\"Inner function to run the resource monitor given a launcher instance.\"\"\"\n        logger.debug(\"Evaluating resource monitor constraints.\")\n        if result := not self.evaluate_constraints():\n            logger.error(\"One or more resource monitor constraints failed.\")\n            raise RuntimeError(\"Resource monitor constraints failed.\")\n        return result\n\n    return _run\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.ResourceMonitor.add_constraint","title":"add_constraint","text":"<pre><code>add_constraint(constraint: Constraint) -&gt; None\n</code></pre> <p>Adds a new constraint to the monitor.</p> <p>Registers a new constraint for monitoring with this resource monitor.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The constraint to add</p> required Example <pre><code>monitor = ResourceMonitor()\n\n# Add storage constraint\nstorage_constraint = available_storage_constraint_factory()\nmonitor.add_constraint(storage_constraint)\n\n# Add custom constraint\ndef check_memory():\n    return psutil.virtual_memory().available &gt; 1e9\n\nmemory_constraint = Constraint(\n    name=\"memory_check\",\n    constraint=check_memory\n)\nmonitor.add_constraint(memory_constraint)\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def add_constraint(self, constraint: Constraint) -&gt; None:\n    \"\"\"\n    Adds a new constraint to the monitor.\n\n    Registers a new constraint for monitoring with this resource monitor.\n\n    Args:\n        constraint: The constraint to add\n\n    Example:\n        ```python\n        monitor = ResourceMonitor()\n\n        # Add storage constraint\n        storage_constraint = available_storage_constraint_factory()\n        monitor.add_constraint(storage_constraint)\n\n        # Add custom constraint\n        def check_memory():\n            return psutil.virtual_memory().available &gt; 1e9\n\n        memory_constraint = Constraint(\n            name=\"memory_check\",\n            constraint=check_memory\n        )\n        monitor.add_constraint(memory_constraint)\n        ```\n    \"\"\"\n    self.constraints.append(constraint)\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.ResourceMonitor.remove_constraint","title":"remove_constraint","text":"<pre><code>remove_constraint(constraint: Constraint) -&gt; None\n</code></pre> <p>Removes a constraint from the monitor.</p> <p>Unregisters a previously added constraint from monitoring.</p> <p>Parameters:</p> Name Type Description Default <code>constraint</code> <code>Constraint</code> <p>The constraint to remove</p> required Example <pre><code>monitor = ResourceMonitor()\nmonitor.add_constraint(constraint)\n\n# Later remove it\nmonitor.remove_constraint(constraint)\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def remove_constraint(self, constraint: Constraint) -&gt; None:\n    \"\"\"\n    Removes a constraint from the monitor.\n\n    Unregisters a previously added constraint from monitoring.\n\n    Args:\n        constraint: The constraint to remove\n\n    Example:\n        ```python\n        monitor = ResourceMonitor()\n        monitor.add_constraint(constraint)\n\n        # Later remove it\n        monitor.remove_constraint(constraint)\n        ```\n    \"\"\"\n    self.constraints.remove(constraint)\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.ResourceMonitor.evaluate_constraints","title":"evaluate_constraints","text":"<pre><code>evaluate_constraints() -&gt; bool\n</code></pre> <p>Evaluates all constraints.</p> <p>Iterates through all registered constraints and evaluates them, logging any failures that occur.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if all constraints are satisfied, False otherwise</p> Example <pre><code>monitor = ResourceMonitor([constraint1, constraint2])\n\n# Check if all constraints pass\nall_passed = monitor.evaluate_constraints()\nif not all_passed:\n    print(\"Some constraints failed - check logs\")\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def evaluate_constraints(self) -&gt; bool:\n    \"\"\"\n    Evaluates all constraints.\n\n    Iterates through all registered constraints and evaluates them, logging\n    any failures that occur.\n\n    Returns:\n        bool: True if all constraints are satisfied, False otherwise\n\n    Example:\n        ```python\n        monitor = ResourceMonitor([constraint1, constraint2])\n\n        # Check if all constraints pass\n        all_passed = monitor.evaluate_constraints()\n        if not all_passed:\n            print(\"Some constraints failed - check logs\")\n        ```\n    \"\"\"\n    for constraint in self.constraints:\n        if not constraint():\n            logger.error(constraint.on_fail())\n            return False\n    return True\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.Constraint","title":"Constraint  <code>dataclass</code>","text":"<pre><code>Constraint(\n    name: str,\n    constraint: Callable[..., bool],\n    args: List = list(),\n    kwargs: dict = dict(),\n    fail_msg_handler: Optional[Callable[..., str]] = None,\n)\n</code></pre> <p>Represents a resource constraint.</p> <p>This class encapsulates a constraint function along with its parameters and failure handling logic for resource monitoring.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the constraint</p> <code>constraint</code> <code>Callable[..., bool]</code> <p>The function to evaluate the constraint</p> <code>args</code> <code>List</code> <p>Positional arguments for the constraint function</p> <code>kwargs</code> <code>dict</code> <p>Keyword arguments for the constraint function</p> <code>fail_msg_handler</code> <code>Optional[Callable[..., str]]</code> <p>A function to generate a failure message</p> Example <pre><code># Simple constraint\ndef check_disk_space(path, min_gb):\n    free_gb = shutil.disk_usage(path).free / (1024**3)\n    return free_gb &gt;= min_gb\n\nconstraint = Constraint(\n    name=\"disk_space_check\",\n    constraint=check_disk_space,\n    kwargs={\"path\": \"C:\\\", \"min_gb\": 10},\n    fail_msg_handler=lambda path, min_gb: f\"Need {min_gb}GB free on {path}\"\n)\n\nsimple_constraint = Constraint(\n    name=\"simple_check\",\n    constraint=lambda x: x &gt; 5)\n\n# Evaluate constraint\nif constraint():\n    print(\"Constraint passed\")\nelse:\n    print(constraint.on_fail())\n\n# Evaluate simple constraint\nif simple_constraint():\n    print(\"Simple constraint passed\")\nelse:\n    print(simple_constraint.on_fail())\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.Constraint.on_fail","title":"on_fail","text":"<pre><code>on_fail() -&gt; str\n</code></pre> <p>Generates a failure message if the constraint is not satisfied.</p> <p>Uses the registered failure message handler or a default message to provide information about constraint failures.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The failure message</p> Example <pre><code>constraint = Constraint(\n    name=\"memory_check\",\n    constraint=lambda: False,  # Always fails\n    fail_msg_handler=lambda: \"Not enough memory available\"\n)\n\nif not constraint():\n    print(constraint.on_fail())  # \"Not enough memory available\"\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_base.py</code> <pre><code>def on_fail(self) -&gt; str:\n    \"\"\"\n    Generates a failure message if the constraint is not satisfied.\n\n    Uses the registered failure message handler or a default message to\n    provide information about constraint failures.\n\n    Returns:\n        str: The failure message\n\n    Example:\n        ```python\n        constraint = Constraint(\n            name=\"memory_check\",\n            constraint=lambda: False,  # Always fails\n            fail_msg_handler=lambda: \"Not enough memory available\"\n        )\n\n        if not constraint():\n            print(constraint.on_fail())  # \"Not enough memory available\"\n        ```\n    \"\"\"\n    if self.fail_msg_handler:\n        return self.fail_msg_handler(*self.args, **self.kwargs)\n    else:\n        return f\"Constraint {self.name} failed.\"\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.available_storage_constraint_factory","title":"available_storage_constraint_factory","text":"<pre><code>available_storage_constraint_factory(\n    drive: PathLike = Path(\"C:\\\\\\\\\"),\n    min_bytes: float = 200000000000.0,\n) -&gt; Constraint\n</code></pre> <p>Creates a constraint to check if a drive has sufficient available storage.</p> <p>This factory function creates a constraint that validates whether the specified drive has enough free space to meet the minimum requirements.</p> <p>Parameters:</p> Name Type Description Default <code>drive</code> <code>PathLike</code> <p>The drive to check. Defaults to \"C:\\\":</p> <code>Path('C:\\\\\\\\')</code> <code>min_bytes</code> <code>float</code> <p>Minimum required free space in bytes. Defaults to 200GB</p> <code>200000000000.0</code> <p>Returns:</p> Name Type Description <code>Constraint</code> <code>Constraint</code> <p>A constraint object for available storage validation</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the drive path is not valid</p> Example <pre><code># Check for default 200GB free space on C: drive\ndefault_storage_constraint = available_storage_constraint_factory()\n\n# Check for 1TB free space on D: drive\nlarge_storage_constraint = available_storage_constraint_factory(\n    drive=\"D:\\\",\n    min_bytes=1e12  # 1TB\n)\n\n# Use in resource monitor\nmonitor = ResourceMonitor()\nmonitor.add_constraint(large_storage_constraint)\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_constraints.py</code> <pre><code>def available_storage_constraint_factory(drive: os.PathLike = Path(r\"C:\\\\\"), min_bytes: float = 2e11) -&gt; Constraint:\n    \"\"\"\n    Creates a constraint to check if a drive has sufficient available storage.\n\n    This factory function creates a constraint that validates whether the specified\n    drive has enough free space to meet the minimum requirements.\n\n    Args:\n        drive: The drive to check. Defaults to \"C:\\\\\":\n        min_bytes: Minimum required free space in bytes. Defaults to 200GB\n\n    Returns:\n        Constraint: A constraint object for available storage validation\n\n    Raises:\n        ValueError: If the drive path is not valid\n\n    Example:\n        ```python\n        # Check for default 200GB free space on C: drive\n        default_storage_constraint = available_storage_constraint_factory()\n\n        # Check for 1TB free space on D: drive\n        large_storage_constraint = available_storage_constraint_factory(\n            drive=\"D:\\\\\",\n            min_bytes=1e12  # 1TB\n        )\n\n        # Use in resource monitor\n        monitor = ResourceMonitor()\n        monitor.add_constraint(large_storage_constraint)\n        ```\n    \"\"\"\n    if not os.path.ismount(drive):\n        drive = os.path.splitdrive(drive)[0] + \"\\\\\"\n    if drive is None:\n        raise ValueError(\"Drive is not valid.\")\n    return Constraint(\n        name=\"available_storage\",\n        constraint=lambda drive, min_bytes: shutil.disk_usage(drive).free &gt;= min_bytes,\n        args=[],\n        kwargs={\"drive\": drive, \"min_bytes\": min_bytes},\n        fail_msg_handler=lambda drive, min_bytes: f\"Drive {drive} does not have enough space.\",\n    )\n</code></pre>"},{"location":"api/resource_monitor/resource_monitor/#clabe.resource_monitor.remote_dir_exists_constraint_factory","title":"remote_dir_exists_constraint_factory","text":"<pre><code>remote_dir_exists_constraint_factory(\n    dir_path: PathLike,\n) -&gt; Constraint\n</code></pre> <p>Creates a constraint to check if a remote directory exists.</p> <p>This factory function creates a constraint that validates whether the specified directory path exists and is accessible.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>PathLike</code> <p>The path of the directory to check</p> required <p>Returns:</p> Name Type Description <code>Constraint</code> <code>Constraint</code> <p>A constraint object for directory existence validation</p> Example <pre><code># Check if network share exists\nnetwork_constraint = remote_dir_exists_constraint_factory(\n    \"\\\\server\\shared_folder\"\n)\n\n# Check if local directory exists\nlocal_constraint = remote_dir_exists_constraint_factory(\n    \"/data/experiments\"\n)\n\n# Use in resource monitor\nmonitor = ResourceMonitor()\nmonitor.add_constraint(network_constraint)\nmonitor.add_constraint(local_constraint)\n\nif monitor.validate():\n    print(\"All directories accessible\")\n</code></pre> Source code in <code>src\\clabe\\resource_monitor\\_constraints.py</code> <pre><code>def remote_dir_exists_constraint_factory(dir_path: os.PathLike) -&gt; Constraint:\n    \"\"\"\n    Creates a constraint to check if a remote directory exists.\n\n    This factory function creates a constraint that validates whether the specified\n    directory path exists and is accessible.\n\n    Args:\n        dir_path: The path of the directory to check\n\n    Returns:\n        Constraint: A constraint object for directory existence validation\n\n    Example:\n        ```python\n        # Check if network share exists\n        network_constraint = remote_dir_exists_constraint_factory(\n            \"\\\\\\\\server\\\\shared_folder\"\n        )\n\n        # Check if local directory exists\n        local_constraint = remote_dir_exists_constraint_factory(\n            \"/data/experiments\"\n        )\n\n        # Use in resource monitor\n        monitor = ResourceMonitor()\n        monitor.add_constraint(network_constraint)\n        monitor.add_constraint(local_constraint)\n\n        if monitor.validate():\n            print(\"All directories accessible\")\n        ```\n    \"\"\"\n    return Constraint(\n        name=\"remote_dir_exists\",\n        constraint=lambda dir_path: os.path.exists(dir_path),\n        args=[],\n        kwargs={\"dir_path\": dir_path},\n        fail_msg_handler=lambda dir_path: f\"Directory {dir_path} does not exist.\",\n    )\n</code></pre>"},{"location":"api/ui/ui/","title":"ui","text":""},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper","title":"DefaultUIHelper","text":"<pre><code>DefaultUIHelper(\n    print_func: _PrintFunc = _DEFAULT_PRINT_FUNC,\n    input_func: _InputFunc = _DEFAULT_INPUT_FUNC,\n)\n</code></pre> <p>               Bases: <code>_UiHelperBase</code></p> <p>Default implementation of the UI helper for user interaction.</p> <p>This class provides a concrete implementation of the UI helper interface using standard console input/output for user interactions.</p> Example <pre><code>helper = DefaultUIHelper()\n\n# Get user choice from list\noptions = [\"Option A\", \"Option B\", \"Option C\"]\nchoice = helper.prompt_pick_from_list(options, \"Choose an option:\")\n\n# Ask yes/no question\nproceed = helper.prompt_yes_no_question(\"Continue with operation?\")\n\n# Get text input\nname = helper.prompt_text(\"Enter your name: \")\n\n# Get numeric input\nvalue = helper.prompt_float(\"Enter a number: \")\n</code></pre> <p>Initializes the DefaultUIHelper with custom print and input functions.</p> <p>Parameters:</p> Name Type Description Default <code>print_func</code> <code>_PrintFunc</code> <p>Custom function for printing messages</p> <code>_DEFAULT_PRINT_FUNC</code> <code>input_func</code> <code>_InputFunc</code> <p>Custom function for receiving user input</p> <code>_DEFAULT_INPUT_FUNC</code> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def __init__(\n    self, print_func: _PrintFunc = _DEFAULT_PRINT_FUNC, input_func: _InputFunc = _DEFAULT_INPUT_FUNC\n) -&gt; None:\n    \"\"\"\n    Initializes the DefaultUIHelper with custom print and input functions.\n\n    Args:\n        print_func: Custom function for printing messages\n        input_func: Custom function for receiving user input\n    \"\"\"\n    self._print = print_func\n    self._input = input_func\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.print","title":"print","text":"<pre><code>print(message: str) -&gt; None\n</code></pre> <p>Prints a message using the configured print function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to print</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>None</code> <p>The result of the print function (usually None)</p> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def print(self, message: str) -&gt; None:\n    \"\"\"\n    Prints a message using the configured print function.\n\n    Args:\n        message: The message to print\n\n    Returns:\n        Any: The result of the print function (usually None)\n    \"\"\"\n    return self._print(message)\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.input","title":"input","text":"<pre><code>input(prompt: str) -&gt; str\n</code></pre> <p>Prompts the user for input using the configured input function.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message to display</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The user input received from the input function</p> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def input(self, prompt: str) -&gt; str:\n    \"\"\"\n    Prompts the user for input using the configured input function.\n\n    Args:\n        prompt: The prompt message to display\n\n    Returns:\n        str: The user input received from the input function\n    \"\"\"\n    return self._input(prompt)\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.prompt_pick_from_list","title":"prompt_pick_from_list","text":"<pre><code>prompt_pick_from_list(\n    value: List[str],\n    prompt: str,\n    allow_0_as_none: bool = True,\n    **kwargs,\n) -&gt; Optional[str]\n</code></pre> <p>Prompts the user to pick an item from a list.</p> <p>Displays a numbered list of options and prompts the user to select one by entering the corresponding number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>List[str]</code> <p>The list of items to choose from</p> required <code>prompt</code> <code>str</code> <p>The prompt message</p> required <code>allow_0_as_none</code> <code>bool</code> <p>Whether to allow 0 as a choice for None</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The selected item or None</p> Example <pre><code>helper = DefaultUIHelper()\nfiles = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\nselected = helper.prompt_pick_from_list(files, \"Choose a file:\")\n\n# With None option disabled\nselected = helper.prompt_pick_from_list(\n    files, \"Must choose a file:\", allow_0_as_none=False\n)\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_pick_from_list(\n    self, value: List[str], prompt: str, allow_0_as_none: bool = True, **kwargs\n) -&gt; Optional[str]:\n    \"\"\"\n    Prompts the user to pick an item from a list.\n\n    Displays a numbered list of options and prompts the user to select\n    one by entering the corresponding number.\n\n    Args:\n        value: The list of items to choose from\n        prompt: The prompt message\n        allow_0_as_none: Whether to allow 0 as a choice for None\n\n    Returns:\n        Optional[str]: The selected item or None\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n        files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n        selected = helper.prompt_pick_from_list(files, \"Choose a file:\")\n\n        # With None option disabled\n        selected = helper.prompt_pick_from_list(\n            files, \"Must choose a file:\", allow_0_as_none=False\n        )\n        ```\n    \"\"\"\n    while True:\n        try:\n            self.print(prompt)\n            if allow_0_as_none:\n                self.print(\"0: None\")\n            for i, item in enumerate(value):\n                self.print(f\"{i + 1}: {item}\")\n            choice = int(input(\"Choice: \"))\n            if choice &lt; 0 or choice &gt;= len(value) + 1:\n                raise ValueError\n            if choice == 0:\n                if allow_0_as_none:\n                    return None\n                else:\n                    raise ValueError\n            return value[choice - 1]\n        except ValueError as e:\n            logger.info(\"Invalid choice. Try again. %s\", e)\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.prompt_yes_no_question","title":"prompt_yes_no_question","text":"<pre><code>prompt_yes_no_question(prompt: str) -&gt; bool\n</code></pre> <p>Prompts the user with a yes/no question.</p> <p>Continues prompting until a valid yes/no response is received.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The question to ask</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True for yes, False for no</p> Example <pre><code>helper = DefaultUIHelper()\n\nif helper.prompt_yes_no_question(\"Save changes?\"):\n    save_data()\n\nproceed = helper.prompt_yes_no_question(\"Delete all files?\")\nif proceed:\n    delete_files()\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_yes_no_question(self, prompt: str) -&gt; bool:\n    \"\"\"\n    Prompts the user with a yes/no question.\n\n    Continues prompting until a valid yes/no response is received.\n\n    Args:\n        prompt: The question to ask\n\n    Returns:\n        bool: True for yes, False for no\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        if helper.prompt_yes_no_question(\"Save changes?\"):\n            save_data()\n\n        proceed = helper.prompt_yes_no_question(\"Delete all files?\")\n        if proceed:\n            delete_files()\n        ```\n    \"\"\"\n    while True:\n        reply = input(prompt + \" (Y\\\\N): \").upper()\n        if reply == \"Y\" or reply == \"1\":\n            return True\n        elif reply == \"N\" or reply == \"0\":\n            return False\n        else:\n            self.print(\"Invalid input. Please enter 'Y' or 'N'.\")\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.prompt_text","title":"prompt_text","text":"<pre><code>prompt_text(prompt: str) -&gt; str\n</code></pre> <p>Prompts the user for text input.</p> <p>Simple text input prompt that returns the user's input as a string.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The user input</p> Example <pre><code>helper = DefaultUIHelper()\n\nname = helper.prompt_text(\"Enter your name: \")\ndescription = helper.prompt_text(\"Enter description: \")\npath = helper.prompt_text(\"Enter file path: \")\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_text(self, prompt: str) -&gt; str:\n    \"\"\"\n    Prompts the user for text input.\n\n    Simple text input prompt that returns the user's input as a string.\n\n    Args:\n        prompt: The prompt message\n\n    Returns:\n        str: The user input\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        name = helper.prompt_text(\"Enter your name: \")\n        description = helper.prompt_text(\"Enter description: \")\n        path = helper.prompt_text(\"Enter file path: \")\n        ```\n    \"\"\"\n    notes = str(input(prompt))\n    return notes\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.DefaultUIHelper.prompt_float","title":"prompt_float","text":"<pre><code>prompt_float(prompt: str) -&gt; float\n</code></pre> <p>Prompts the user for a float input.</p> <p>Continues prompting until a valid float value is entered.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The parsed user input</p> Example <pre><code>helper = DefaultUIHelper()\n\ntemperature = helper.prompt_float(\"Enter temperature: \")\nweight = helper.prompt_float(\"Enter weight in kg: \")\nprice = helper.prompt_float(\"Enter price: $\")\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_float(self, prompt: str) -&gt; float:\n    \"\"\"\n    Prompts the user for a float input.\n\n    Continues prompting until a valid float value is entered.\n\n    Args:\n        prompt: The prompt message\n\n    Returns:\n        float: The parsed user input\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        temperature = helper.prompt_float(\"Enter temperature: \")\n        weight = helper.prompt_float(\"Enter weight in kg: \")\n        price = helper.prompt_float(\"Enter price: $\")\n        ```\n    \"\"\"\n    while True:\n        try:\n            value = float(input(prompt))\n            return value\n        except ValueError:\n            self.print(\"Invalid input. Please enter a valid float.\")\n</code></pre>"},{"location":"api/ui/ui/#clabe.ui.prompt_field_from_input","title":"prompt_field_from_input","text":"<pre><code>prompt_field_from_input(\n    model: Type[_TModel],\n    field_name: str,\n    default: Optional[_T] = None,\n) -&gt; Optional[_T]\n</code></pre> <p>Prompts the user to input a value for a specific field in a model.</p> <p>Uses the model's field information to prompt for input and validates the entered value against the field's type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[_TModel]</code> <p>The model containing the field</p> required <code>field_name</code> <code>str</code> <p>The name of the field</p> required <code>default</code> <code>Optional[_T]</code> <p>The default value if no input is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[_T]</code> <p>Optional[_T]: The validated input value or the default value</p> Example <pre><code>from pydantic import BaseModel, Field\n\nclass UserModel(BaseModel):\n    name: str = Field(description=\"User's full name\")\n    age: int = Field(description=\"User's age in years\")\n\n# Prompt for name field\nname = prompt_field_from_input(UserModel, \"name\", \"Anonymous\")\n\n# Prompt for age field\nage = prompt_field_from_input(UserModel, \"age\", 18)\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_field_from_input(model: Type[_TModel], field_name: str, default: Optional[_T] = None) -&gt; Optional[_T]:\n    \"\"\"\n    Prompts the user to input a value for a specific field in a model.\n\n    Uses the model's field information to prompt for input and validates the\n    entered value against the field's type annotation.\n\n    Args:\n        model: The model containing the field\n        field_name: The name of the field\n        default: The default value if no input is provided\n\n    Returns:\n        Optional[_T]: The validated input value or the default value\n\n    Example:\n        ```python\n        from pydantic import BaseModel, Field\n\n        class UserModel(BaseModel):\n            name: str = Field(description=\"User's full name\")\n            age: int = Field(description=\"User's age in years\")\n\n        # Prompt for name field\n        name = prompt_field_from_input(UserModel, \"name\", \"Anonymous\")\n\n        # Prompt for age field\n        age = prompt_field_from_input(UserModel, \"age\", 18)\n        ```\n    \"\"\"\n    _field = model.model_fields[field_name]\n    _type_adaptor: TypeAdapter = TypeAdapter(_field.annotation)\n    value: Optional[_T] | str\n    _in = input(f\"Enter {field_name} ({_field.description}): \")\n    value = _in if _in != \"\" else default\n    return _type_adaptor.validate_python(value)\n</code></pre>"},{"location":"api/ui/ui_helper/","title":"ui.ui_helper","text":""},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper","title":"DefaultUIHelper","text":"<pre><code>DefaultUIHelper(\n    print_func: _PrintFunc = _DEFAULT_PRINT_FUNC,\n    input_func: _InputFunc = _DEFAULT_INPUT_FUNC,\n)\n</code></pre> <p>               Bases: <code>_UiHelperBase</code></p> <p>Default implementation of the UI helper for user interaction.</p> <p>This class provides a concrete implementation of the UI helper interface using standard console input/output for user interactions.</p> Example <pre><code>helper = DefaultUIHelper()\n\n# Get user choice from list\noptions = [\"Option A\", \"Option B\", \"Option C\"]\nchoice = helper.prompt_pick_from_list(options, \"Choose an option:\")\n\n# Ask yes/no question\nproceed = helper.prompt_yes_no_question(\"Continue with operation?\")\n\n# Get text input\nname = helper.prompt_text(\"Enter your name: \")\n\n# Get numeric input\nvalue = helper.prompt_float(\"Enter a number: \")\n</code></pre> <p>Initializes the DefaultUIHelper with custom print and input functions.</p> <p>Parameters:</p> Name Type Description Default <code>print_func</code> <code>_PrintFunc</code> <p>Custom function for printing messages</p> <code>_DEFAULT_PRINT_FUNC</code> <code>input_func</code> <code>_InputFunc</code> <p>Custom function for receiving user input</p> <code>_DEFAULT_INPUT_FUNC</code> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def __init__(\n    self, print_func: _PrintFunc = _DEFAULT_PRINT_FUNC, input_func: _InputFunc = _DEFAULT_INPUT_FUNC\n) -&gt; None:\n    \"\"\"\n    Initializes the DefaultUIHelper with custom print and input functions.\n\n    Args:\n        print_func: Custom function for printing messages\n        input_func: Custom function for receiving user input\n    \"\"\"\n    self._print = print_func\n    self._input = input_func\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.print","title":"print","text":"<pre><code>print(message: str) -&gt; None\n</code></pre> <p>Prints a message using the configured print function.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to print</p> required <p>Returns:</p> Name Type Description <code>Any</code> <code>None</code> <p>The result of the print function (usually None)</p> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def print(self, message: str) -&gt; None:\n    \"\"\"\n    Prints a message using the configured print function.\n\n    Args:\n        message: The message to print\n\n    Returns:\n        Any: The result of the print function (usually None)\n    \"\"\"\n    return self._print(message)\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.input","title":"input","text":"<pre><code>input(prompt: str) -&gt; str\n</code></pre> <p>Prompts the user for input using the configured input function.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message to display</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The user input received from the input function</p> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def input(self, prompt: str) -&gt; str:\n    \"\"\"\n    Prompts the user for input using the configured input function.\n\n    Args:\n        prompt: The prompt message to display\n\n    Returns:\n        str: The user input received from the input function\n    \"\"\"\n    return self._input(prompt)\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.prompt_pick_from_list","title":"prompt_pick_from_list","text":"<pre><code>prompt_pick_from_list(\n    value: List[str],\n    prompt: str,\n    allow_0_as_none: bool = True,\n    **kwargs,\n) -&gt; Optional[str]\n</code></pre> <p>Prompts the user to pick an item from a list.</p> <p>Displays a numbered list of options and prompts the user to select one by entering the corresponding number.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>List[str]</code> <p>The list of items to choose from</p> required <code>prompt</code> <code>str</code> <p>The prompt message</p> required <code>allow_0_as_none</code> <code>bool</code> <p>Whether to allow 0 as a choice for None</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The selected item or None</p> Example <pre><code>helper = DefaultUIHelper()\nfiles = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\nselected = helper.prompt_pick_from_list(files, \"Choose a file:\")\n\n# With None option disabled\nselected = helper.prompt_pick_from_list(\n    files, \"Must choose a file:\", allow_0_as_none=False\n)\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_pick_from_list(\n    self, value: List[str], prompt: str, allow_0_as_none: bool = True, **kwargs\n) -&gt; Optional[str]:\n    \"\"\"\n    Prompts the user to pick an item from a list.\n\n    Displays a numbered list of options and prompts the user to select\n    one by entering the corresponding number.\n\n    Args:\n        value: The list of items to choose from\n        prompt: The prompt message\n        allow_0_as_none: Whether to allow 0 as a choice for None\n\n    Returns:\n        Optional[str]: The selected item or None\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n        files = [\"file1.txt\", \"file2.txt\", \"file3.txt\"]\n        selected = helper.prompt_pick_from_list(files, \"Choose a file:\")\n\n        # With None option disabled\n        selected = helper.prompt_pick_from_list(\n            files, \"Must choose a file:\", allow_0_as_none=False\n        )\n        ```\n    \"\"\"\n    while True:\n        try:\n            self.print(prompt)\n            if allow_0_as_none:\n                self.print(\"0: None\")\n            for i, item in enumerate(value):\n                self.print(f\"{i + 1}: {item}\")\n            choice = int(input(\"Choice: \"))\n            if choice &lt; 0 or choice &gt;= len(value) + 1:\n                raise ValueError\n            if choice == 0:\n                if allow_0_as_none:\n                    return None\n                else:\n                    raise ValueError\n            return value[choice - 1]\n        except ValueError as e:\n            logger.info(\"Invalid choice. Try again. %s\", e)\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.prompt_yes_no_question","title":"prompt_yes_no_question","text":"<pre><code>prompt_yes_no_question(prompt: str) -&gt; bool\n</code></pre> <p>Prompts the user with a yes/no question.</p> <p>Continues prompting until a valid yes/no response is received.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The question to ask</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True for yes, False for no</p> Example <pre><code>helper = DefaultUIHelper()\n\nif helper.prompt_yes_no_question(\"Save changes?\"):\n    save_data()\n\nproceed = helper.prompt_yes_no_question(\"Delete all files?\")\nif proceed:\n    delete_files()\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_yes_no_question(self, prompt: str) -&gt; bool:\n    \"\"\"\n    Prompts the user with a yes/no question.\n\n    Continues prompting until a valid yes/no response is received.\n\n    Args:\n        prompt: The question to ask\n\n    Returns:\n        bool: True for yes, False for no\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        if helper.prompt_yes_no_question(\"Save changes?\"):\n            save_data()\n\n        proceed = helper.prompt_yes_no_question(\"Delete all files?\")\n        if proceed:\n            delete_files()\n        ```\n    \"\"\"\n    while True:\n        reply = input(prompt + \" (Y\\\\N): \").upper()\n        if reply == \"Y\" or reply == \"1\":\n            return True\n        elif reply == \"N\" or reply == \"0\":\n            return False\n        else:\n            self.print(\"Invalid input. Please enter 'Y' or 'N'.\")\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.prompt_text","title":"prompt_text","text":"<pre><code>prompt_text(prompt: str) -&gt; str\n</code></pre> <p>Prompts the user for text input.</p> <p>Simple text input prompt that returns the user's input as a string.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The user input</p> Example <pre><code>helper = DefaultUIHelper()\n\nname = helper.prompt_text(\"Enter your name: \")\ndescription = helper.prompt_text(\"Enter description: \")\npath = helper.prompt_text(\"Enter file path: \")\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_text(self, prompt: str) -&gt; str:\n    \"\"\"\n    Prompts the user for text input.\n\n    Simple text input prompt that returns the user's input as a string.\n\n    Args:\n        prompt: The prompt message\n\n    Returns:\n        str: The user input\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        name = helper.prompt_text(\"Enter your name: \")\n        description = helper.prompt_text(\"Enter description: \")\n        path = helper.prompt_text(\"Enter file path: \")\n        ```\n    \"\"\"\n    notes = str(input(prompt))\n    return notes\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.DefaultUIHelper.prompt_float","title":"prompt_float","text":"<pre><code>prompt_float(prompt: str) -&gt; float\n</code></pre> <p>Prompts the user for a float input.</p> <p>Continues prompting until a valid float value is entered.</p> <p>Parameters:</p> Name Type Description Default <code>prompt</code> <code>str</code> <p>The prompt message</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The parsed user input</p> Example <pre><code>helper = DefaultUIHelper()\n\ntemperature = helper.prompt_float(\"Enter temperature: \")\nweight = helper.prompt_float(\"Enter weight in kg: \")\nprice = helper.prompt_float(\"Enter price: $\")\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_float(self, prompt: str) -&gt; float:\n    \"\"\"\n    Prompts the user for a float input.\n\n    Continues prompting until a valid float value is entered.\n\n    Args:\n        prompt: The prompt message\n\n    Returns:\n        float: The parsed user input\n\n    Example:\n        ```python\n        helper = DefaultUIHelper()\n\n        temperature = helper.prompt_float(\"Enter temperature: \")\n        weight = helper.prompt_float(\"Enter weight in kg: \")\n        price = helper.prompt_float(\"Enter price: $\")\n        ```\n    \"\"\"\n    while True:\n        try:\n            value = float(input(prompt))\n            return value\n        except ValueError:\n            self.print(\"Invalid input. Please enter a valid float.\")\n</code></pre>"},{"location":"api/ui/ui_helper/#clabe.ui.ui_helper.prompt_field_from_input","title":"prompt_field_from_input","text":"<pre><code>prompt_field_from_input(\n    model: Type[_TModel],\n    field_name: str,\n    default: Optional[_T] = None,\n) -&gt; Optional[_T]\n</code></pre> <p>Prompts the user to input a value for a specific field in a model.</p> <p>Uses the model's field information to prompt for input and validates the entered value against the field's type annotation.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Type[_TModel]</code> <p>The model containing the field</p> required <code>field_name</code> <code>str</code> <p>The name of the field</p> required <code>default</code> <code>Optional[_T]</code> <p>The default value if no input is provided</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[_T]</code> <p>Optional[_T]: The validated input value or the default value</p> Example <pre><code>from pydantic import BaseModel, Field\n\nclass UserModel(BaseModel):\n    name: str = Field(description=\"User's full name\")\n    age: int = Field(description=\"User's age in years\")\n\n# Prompt for name field\nname = prompt_field_from_input(UserModel, \"name\", \"Anonymous\")\n\n# Prompt for age field\nage = prompt_field_from_input(UserModel, \"age\", 18)\n</code></pre> Source code in <code>src\\clabe\\ui\\ui_helper.py</code> <pre><code>def prompt_field_from_input(model: Type[_TModel], field_name: str, default: Optional[_T] = None) -&gt; Optional[_T]:\n    \"\"\"\n    Prompts the user to input a value for a specific field in a model.\n\n    Uses the model's field information to prompt for input and validates the\n    entered value against the field's type annotation.\n\n    Args:\n        model: The model containing the field\n        field_name: The name of the field\n        default: The default value if no input is provided\n\n    Returns:\n        Optional[_T]: The validated input value or the default value\n\n    Example:\n        ```python\n        from pydantic import BaseModel, Field\n\n        class UserModel(BaseModel):\n            name: str = Field(description=\"User's full name\")\n            age: int = Field(description=\"User's age in years\")\n\n        # Prompt for name field\n        name = prompt_field_from_input(UserModel, \"name\", \"Anonymous\")\n\n        # Prompt for age field\n        age = prompt_field_from_input(UserModel, \"age\", 18)\n        ```\n    \"\"\"\n    _field = model.model_fields[field_name]\n    _type_adaptor: TypeAdapter = TypeAdapter(_field.annotation)\n    value: Optional[_T] | str\n    _in = input(f\"Enter {field_name} ({_field.description}): \")\n    value = _in if _in != \"\" else default\n    return _type_adaptor.validate_python(value)\n</code></pre>"},{"location":"api/utils/aind_auth/","title":"utils.aind_auth","text":""},{"location":"api/utils/aind_auth/#clabe.utils.aind_auth.validate_aind_username","title":"validate_aind_username","text":"<pre><code>validate_aind_username(\n    username: str,\n    domain: str = \"corp.alleninstitute.org\",\n    domain_username: Optional[str] = None,\n    timeout: Optional[float] = 2,\n) -&gt; bool\n</code></pre> <p>Validates if the given username is in the AIND Active Directory.</p> <p>This function is a no-op on non-Windows platforms since Active Directory authentication is not available.</p> <p>This function always returns True on non-Windows platforms.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username to validate (ignored on non-Windows platforms)</p> required <code>domain</code> <code>str</code> <p>The Active Directory domain (ignored on non-Windows platforms)</p> <code>'corp.alleninstitute.org'</code> <code>domain_username</code> <code>Optional[str]</code> <p>Username for domain authentication (ignored on non-Windows platforms)</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>Timeout for the validation operation (ignored on non-Windows platforms)</p> <code>2</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Always returns True on non-Windows platforms</p> Source code in <code>src\\clabe\\utils\\aind_auth.py</code> <pre><code>def validate_aind_username(\n    username: str,\n    domain: str = \"corp.alleninstitute.org\",\n    domain_username: Optional[str] = None,\n    timeout: Optional[float] = 2,\n) -&gt; bool:\n    \"\"\"\n    Validates if the given username is in the AIND Active Directory.\n\n    This function is a no-op on non-Windows platforms since Active Directory\n    authentication is not available.\n\n    This function always returns True on non-Windows platforms.\n\n    Args:\n        username: The username to validate (ignored on non-Windows platforms)\n        domain: The Active Directory domain (ignored on non-Windows platforms)\n        domain_username: Username for domain authentication (ignored on non-Windows platforms)\n        timeout: Timeout for the validation operation (ignored on non-Windows platforms)\n\n    Returns:\n        bool: Always returns True on non-Windows platforms\n    \"\"\"\n    logger.warning(\"Active Directory validation is not implemented for non-Windows platforms\")\n    return True\n</code></pre>"},{"location":"api/utils/keepass/","title":"utils.keepass","text":""},{"location":"api/utils/keepass/#clabe.utils.keepass.KeePassSettings","title":"KeePassSettings","text":"<p>               Bases: <code>ServiceSettings</code></p> <p>Settings for the KeePass service.</p> <p>This class provides configuration settings for accessing KeePass password databases. It supports authentication using both keyfiles and passwords, with automatic YAML configuration loading through the ServiceSettings base class.</p> <p>Attributes:</p> Name Type Description <code>database</code> <code>Path</code> <p>Path to the KeePass database file (.kdbx).</p> <code>keyfile</code> <code>Optional[Path]</code> <p>Path to the keyfile for database authentication. Can be None if using password-only authentication.</p> <code>password</code> <code>Optional[str]</code> <p>Master password for the database. Can be None if using keyfile-only authentication.</p> Example <pre><code># Using default settings\nsettings = KeePassSettings()\n\n# Using custom settings\nsettings = KeePassSettings(\n    database=Path(\"/path/to/database.kdbx\"),\n    keyfile=Path(\"/path/to/keyfile.key\"),\n    password=\"master_password\"\n)\n</code></pre>"},{"location":"api/utils/keepass/#clabe.utils.keepass.KeePassSettings.settings_customise_sources","title":"settings_customise_sources  <code>classmethod</code>","text":"<pre><code>settings_customise_sources(\n    settings_cls: Type[BaseSettings],\n    init_settings: PydanticBaseSettingsSource,\n    env_settings: PydanticBaseSettingsSource,\n    dotenv_settings: PydanticBaseSettingsSource,\n    file_secret_settings: PydanticBaseSettingsSource,\n) -&gt; Tuple[PydanticBaseSettingsSource, ...]\n</code></pre> <p>Customizes the settings sources to include the safe YAML settings source.</p> <p>Parameters:</p> Name Type Description Default <code>settings_cls</code> <code>Type[BaseSettings]</code> <p>The settings class.</p> required <code>init_settings</code> <code>PydanticBaseSettingsSource</code> <p>The initial settings source.</p> required <code>env_settings</code> <code>PydanticBaseSettingsSource</code> <p>The environment settings source.</p> required <code>dotenv_settings</code> <code>PydanticBaseSettingsSource</code> <p>The dotenv settings source.</p> required <code>file_secret_settings</code> <code>PydanticBaseSettingsSource</code> <p>The file secret settings source.</p> required <p>Returns:</p> Type Description <code>Tuple[PydanticBaseSettingsSource, ...]</code> <p>A tuple of settings sources.</p> Source code in <code>src\\clabe\\services.py</code> <pre><code>@classmethod\ndef settings_customise_sources(\n    cls,\n    settings_cls: t.Type[ps.BaseSettings],\n    init_settings: ps.PydanticBaseSettingsSource,\n    env_settings: ps.PydanticBaseSettingsSource,\n    dotenv_settings: ps.PydanticBaseSettingsSource,\n    file_secret_settings: ps.PydanticBaseSettingsSource,\n) -&gt; t.Tuple[ps.PydanticBaseSettingsSource, ...]:\n    \"\"\"\n    Customizes the settings sources to include the safe YAML settings source.\n\n    Args:\n        settings_cls: The settings class.\n        init_settings: The initial settings source.\n        env_settings: The environment settings source.\n        dotenv_settings: The dotenv settings source.\n        file_secret_settings: The file secret settings source.\n\n    Returns:\n        A tuple of settings sources.\n    \"\"\"\n    return (\n        init_settings,\n        _SafeYamlSettingsSource(settings_cls),\n        env_settings,\n        dotenv_settings,\n        file_secret_settings,\n    )\n</code></pre>"},{"location":"api/utils/keepass/#clabe.utils.keepass.KeePass","title":"KeePass","text":"<pre><code>KeePass(settings: KeePassSettings)\n</code></pre> <p>               Bases: <code>Service</code></p> <p>KeePass password manager service for accessing password database entries.</p> <p>This service provides a simple interface for connecting to and retrieving entries from KeePass password databases. It handles authentication using the provided settings and supports both keyfile and password-based authentication methods.</p> <p>The service automatically establishes a connection to the database upon initialization and provides methods for retrieving password entries by title.</p> <p>Attributes:</p> Name Type Description <code>_settings</code> <code>KeePassSettings</code> <p>Configuration settings for the KeePass database.</p> <code>_keepass</code> <code>PyKeePass</code> <p>The underlying PyKeePass instance for database operations.</p> Example <pre><code># Create settings and service\nsettings = KeePassSettings(\n    database=Path(\"/path/to/database.kdbx\"),\n    password=\"master_password\"\n)\nkeepass = KeePass(settings)\n\n# Retrieve an entry\nentry = keepass.get_entry(\"my_service_credentials\")\nusername = entry.username\npassword = entry.password\n</code></pre> <p>Initialize the KeePass service with the provided settings.</p> <p>Creates a connection to the KeePass database using the authentication credentials specified in the settings. The connection is established immediately upon initialization.</p> <p>Parameters:</p> Name Type Description Default <code>settings</code> <code>KeePassSettings</code> <p>Configuration settings containing database path and authentication credentials.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the database file cannot be found.</p> <code>CredentialsError</code> <p>If the provided authentication credentials are invalid.</p> <code>IOError</code> <p>If there's an error reading the database or keyfile.</p> Example <pre><code>settings = KeePassSettings(database=Path(\"passwords.kdbx\"))\nkeepass = KeePass(settings)\n</code></pre> Source code in <code>src\\clabe\\utils\\keepass.py</code> <pre><code>def __init__(self, settings: KeePassSettings):\n    \"\"\"\n    Initialize the KeePass service with the provided settings.\n\n    Creates a connection to the KeePass database using the authentication\n    credentials specified in the settings. The connection is established\n    immediately upon initialization.\n\n    Args:\n        settings (KeePassSettings): Configuration settings containing database\n            path and authentication credentials.\n\n    Raises:\n        FileNotFoundError: If the database file cannot be found.\n        CredentialsError: If the provided authentication credentials are invalid.\n        IOError: If there's an error reading the database or keyfile.\n\n    Example:\n        ```python\n        settings = KeePassSettings(database=Path(\"passwords.kdbx\"))\n        keepass = KeePass(settings)\n        ```\n    \"\"\"\n    self._settings = settings\n    self._keepass = PyKeePass(\n        filename=self._settings.database,\n        password=self._settings.password,\n        keyfile=self._settings.keyfile,\n    )\n</code></pre>"},{"location":"api/utils/keepass/#clabe.utils.keepass.KeePass.get_entry","title":"get_entry","text":"<pre><code>get_entry(title: str) -&gt; Entry\n</code></pre> <p>Retrieve a password entry from the database by title.</p> <p>Searches the KeePass database for entries matching the specified title and returns the first match found. Entry titles are typically unique within a database, but if multiple entries share the same title, only the first one encountered will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the entry to retrieve. This should match the entry title exactly (case-sensitive).</p> required <p>Returns:</p> Name Type Description <code>Entry</code> <code>Entry</code> <p>The KeePass entry object containing username, password, and other metadata associated with the specified title.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no entry is found with the specified title.</p> Example <pre><code># Retrieve credentials for a service\nentry = keepass.get_entry(\"GitHub API Token\")\ntoken = entry.password\n\n# Access other entry properties\nusername = entry.username\nurl = entry.url\nnotes = entry.notes\n</code></pre> Source code in <code>src\\clabe\\utils\\keepass.py</code> <pre><code>def get_entry(self, title: str) -&gt; Entry:\n    \"\"\"\n    Retrieve a password entry from the database by title.\n\n    Searches the KeePass database for entries matching the specified title\n    and returns the first match found. Entry titles are typically unique\n    within a database, but if multiple entries share the same title,\n    only the first one encountered will be returned.\n\n    Args:\n        title (str): The title of the entry to retrieve. This should match\n            the entry title exactly (case-sensitive).\n\n    Returns:\n        Entry: The KeePass entry object containing username, password, and\n            other metadata associated with the specified title.\n\n    Raises:\n        ValueError: If no entry is found with the specified title.\n\n    Example:\n        ```python\n        # Retrieve credentials for a service\n        entry = keepass.get_entry(\"GitHub API Token\")\n        token = entry.password\n\n        # Access other entry properties\n        username = entry.username\n        url = entry.url\n        notes = entry.notes\n        ```\n    \"\"\"\n    entries = self._keepass.find_entries(title=title)\n    if not entries:\n        raise ValueError(f\"No entry found with title '{title}'\")\n    else:\n        return entries[0]\n</code></pre>"},{"location":"api/utils/utils/","title":"utils","text":"<p>Constants used throughout the CLABE package.</p>"},{"location":"api/utils/utils/#clabe.utils.ByAnimalFiles","title":"ByAnimalFiles","text":"<p>               Bases: <code>StrEnum</code></p> <p>Enum for file types associated with animals in the experiment.</p> <p>Defines the standard file types that can be associated with individual animals/subjects in behavior experiments.</p> Example <pre><code># Use the task logic file type\nfilename = f\"{ByAnimalFiles.TASK_LOGIC}.json\"\n</code></pre>"},{"location":"api/utils/utils/#clabe.utils.abspath","title":"abspath","text":"<pre><code>abspath(path: PathLike) -&gt; Path\n</code></pre> <p>Helper method that converts a path to an absolute path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>PathLike</code> <p>The path to convert</p> required <p>Returns:</p> Name Type Description <code>Path</code> <code>Path</code> <p>The absolute path</p> Source code in <code>src\\clabe\\utils\\__init__.py</code> <pre><code>def abspath(path: os.PathLike) -&gt; Path:\n    \"\"\"\n    Helper method that converts a path to an absolute path.\n\n    Args:\n        path: The path to convert\n\n    Returns:\n        Path: The absolute path\n    \"\"\"\n    return Path(path).resolve()\n</code></pre>"},{"location":"docs_examples/behavior_launcher/","title":"AIND Behavior Launcher Example","text":""},{"location":"docs_examples/behavior_launcher/#example-code","title":"Example Code","text":"<p>The following example shows how to instantiate a behavior launcher that interfaces with AIND infrastructure.</p> <pre><code>import datetime\nimport logging\nimport os\nimport subprocess\nfrom pathlib import Path\nfrom typing import Any, Callable, Dict, Literal, Optional, Self, Union\n\nimport git\nfrom aind_behavior_curriculum import Stage, TrainerState\nfrom aind_behavior_services.rig import AindBehaviorRigModel\nfrom aind_behavior_services.session import AindBehaviorSessionModel\nfrom aind_behavior_services.task_logic import AindBehaviorTaskLogicModel\nfrom pydantic import Field\nfrom pydantic_settings import CliApp\n\nfrom clabe import resource_monitor\nfrom clabe.apps import App, CurriculumApp, CurriculumSettings\nfrom clabe.data_mapper import DataMapper\nfrom clabe.data_transfer.aind_watchdog import WatchdogDataTransferService, WatchdogSettings\nfrom clabe.launcher import (\n    Launcher,\n    LauncherCliArgs,\n    ignore_errors,\n)\nfrom clabe.pickers import DefaultBehaviorPicker, DefaultBehaviorPickerSettings\n\nlogger = logging.getLogger(__name__)\n\nTASK_NAME = \"RandomTask\"\nLIB_CONFIG = rf\"local\\AindBehavior.db\\{TASK_NAME}\"\n\n\n### Task-specific definitions\nclass RigModel(AindBehaviorRigModel):\n    rig_name: str = Field(default=\"TestRig\", description=\"Rig name\")\n    version: Literal[\"0.0.0\"] = \"0.0.0\"\n\n\nclass TaskLogicModel(AindBehaviorTaskLogicModel):\n    version: Literal[\"0.0.0\"] = \"0.0.0\"\n    name: Literal[TASK_NAME] = TASK_NAME\n\n\nmock_trainer_state = TrainerState[Any](\n    curriculum=None,\n    is_on_curriculum=False,\n    stage=Stage(name=\"TestStage\", task=TaskLogicModel(name=TASK_NAME, task_parameters={\"foo\": \"bar\"})),\n)\n\n\nclass MockAindDataSchemaSession:\n    def __init__(\n        self,\n        computer_name: Optional[str] = None,\n        repository: Optional[Union[os.PathLike, git.Repo]] = None,\n        task_name: Optional[str] = None,\n    ):\n        self.computer_name = computer_name\n        self.repository = repository\n        self.task_name = task_name\n\n    def __str__(self) -&gt; str:\n        return f\"MockAindDataSchemaSession(computer_name={self.computer_name}, repository={self.repository}, task_name={self.task_name})\"\n\n\nclass DemoAindDataSchemaSessionDataMapper(DataMapper[MockAindDataSchemaSession]):\n    def __init__(\n        self,\n        session_model: AindBehaviorSessionModel,\n        rig_model: RigModel,\n        task_logic_model: TaskLogicModel,\n        repository: Union[os.PathLike, git.Repo],\n        script_path: os.PathLike,\n        session_end_time: Optional[datetime.datetime] = None,\n        output_parameters: Optional[Dict] = None,\n    ):\n        super().__init__()\n        self.session_model = session_model\n        self.rig_model = rig_model\n        self.task_logic_model = task_logic_model\n        self.repository = repository\n        self.script_path = script_path\n        self.session_end_time = session_end_time\n        self.output_parameters = output_parameters\n        self._mapped: Optional[MockAindDataSchemaSession] = None\n\n    def map(self) -&gt; MockAindDataSchemaSession:\n        self._mapped = MockAindDataSchemaSession(\n            computer_name=self.rig_model.computer_name, repository=self.repository, task_name=self.task_logic_model.name\n        )\n        print(\"#\" * 50)\n        print(\"THIS IS MAPPED DATA!\")\n        print(\"#\" * 50)\n        print(self._mapped)\n        return self._mapped\n\n    @classmethod\n    def builder_runner(\n        cls,\n        script_path: os.PathLike,\n        session_end_time: Optional[datetime.datetime] = None,\n        output_parameters: Optional[Dict] = None,\n    ) -&gt; Callable[[Launcher], Self]:\n        def _run(launcher: Launcher) -&gt; Self:\n            logger.info(\"Running DemoAindDataSchemaSessionDataMapper...\")\n            new = cls(\n                session_model=launcher.get_session(strict=True),\n                rig_model=launcher.get_rig(strict=True),\n                task_logic_model=launcher.get_task_logic(strict=True),\n                repository=launcher.repository,\n                script_path=script_path,\n                session_end_time=session_end_time or datetime.datetime.now(),\n                output_parameters=output_parameters,\n            )\n            logger.info(\"DemoAindDataSchemaSessionDataMapper completed.\")\n            new.map()\n            return new\n\n        return _run\n\n\nclass MockWatchdogService(WatchdogDataTransferService):\n    def __init__(self, *args, **kwargs):\n        os.environ[\"WATCHDOG_EXE\"] = \"mock_executable\"\n        os.environ[\"WATCHDOG_CONFIG\"] = \"mock_config\"\n        super().__init__(*args, **kwargs)\n\n    def transfer(self) -&gt; None:\n        logger.info(\"MockWatchdogService: Transfer method called.\")\n        logger.info(\"Validating watchdog service...\")\n        self.validate()\n        logger.info(\"Watchdog service validated successfully.\")\n        logger.info(\"MockWatchdogService: Data transfer completed successfully.\")\n\n    def validate(self, *args, **kwargs) -&gt; bool:\n        return True\n\n\nclass EchoApp(App):\n    def __init__(self, value: str) -&gt; None:\n        self._value = value\n        self._result = None\n\n    def run(self) -&gt; subprocess.CompletedProcess:\n        logger.info(\"Running EchoApp...\")\n        command = [\"cmd\", \"/c\", \"echo\", self._value]\n\n        try:\n            proc = subprocess.run(\n                command,\n                shell=True,\n                capture_output=True,\n                text=True,\n                check=True,\n            )\n        except subprocess.CalledProcessError as e:\n            logger.error(\"%s\", e)\n            raise\n        self._result = proc\n        logger.info(\"EchoApp completed.\")\n        return proc\n\n    def output_from_result(self, allow_stderr: Optional[bool]) -&gt; Self:\n        proc = self.result\n        try:\n            proc.check_returncode()\n        except subprocess.CalledProcessError:\n            self._log_process_std_output(\"echo\", proc)\n            raise\n        else:\n            self._log_process_std_output(\"echo\", proc)\n            if len(proc.stdout) &gt; 0 and allow_stderr is False:\n                raise subprocess.CalledProcessError(1, proc.args)\n        return self\n\n    def _log_process_std_output(self, process_name: str, proc: subprocess.CompletedProcess) -&gt; None:\n        if len(proc.stdout) &gt; 0:\n            logger.info(\"%s full stdout dump: \\n%s\", process_name, proc.stdout)\n        if len(proc.stderr) &gt; 0:\n            logger.error(\"%s full stderr dump: \\n%s\", process_name, proc.stderr)\n\n    @property\n    def result(self) -&gt; subprocess.CompletedProcess:\n        if self._result is None:\n            raise RuntimeError(\"The app has not been run yet.\")\n        return self._result\n\n    def build_runner(self, *args, **kwargs) -&gt; Callable[[Launcher], Any]:\n        return lambda launcher: self.run()\n\n\ndef make_launcher():\n    behavior_cli_args = CliApp.run(\n        LauncherCliArgs,\n        cli_args=[\"--temp-dir\", \"./local/.temp\", \"--allow-dirty\", \"--skip-hardware-validation\", \"--data-dir\", \".\"],\n    )\n\n    DATA_DIR = Path(r\"./local/data\")\n\n    monitor = resource_monitor.ResourceMonitor(\n        constrains=[\n            resource_monitor.available_storage_constraint_factory(DATA_DIR, 2e11),\n            resource_monitor.remote_dir_exists_constraint_factory(Path(r\"C:/\")),\n        ]\n    )\n\n    watchdog_settings = WatchdogSettings(\n        destination=Path(r\"./local/data\"),\n        project_name=\"my_project\",\n    )\n\n    launcher = Launcher(\n        rig=RigModel,\n        session=AindBehaviorSessionModel,\n        task_logic=TaskLogicModel,\n        settings=behavior_cli_args,\n    )\n\n    picker = DefaultBehaviorPicker(settings=DefaultBehaviorPickerSettings(config_library_dir=LIB_CONFIG))\n\n    launcher.register_callable(\n        [\n            picker.initialize,\n            picker.pick_session,\n            picker.pick_trainer_state,\n            picker.pick_rig,\n        ]\n    )\n    launcher.register_callable(monitor.build_runner())\n    launcher.register_callable(EchoApp(\"Hello World!\").build_runner(allow_std_error=True))\n    launcher.register_callable(\n        CurriculumApp(\n            settings=CurriculumSettings(\n                curriculum=\"template\",\n                data_directory=Path(\"demo\"),\n                project_directory=Path(\"./tests/assets/Aind.Behavior.VrForaging.Curricula\"),\n            )\n        ).build_runner(lambda: mock_trainer_state)\n    )\n    output = launcher.register_callable(DemoAindDataSchemaSessionDataMapper.builder_runner(Path(\"./mock/script.py\")))\n    launcher.register_callable(lambda x: x.copy_logs())\n    launcher.register_callable(\n        MockWatchdogService.build_runner(settings=watchdog_settings, aind_session_data_mapper=output)\n    )\n\n    def raises_error(x: Launcher) -&gt; int:\n        raise ValueError(\"This is a test error.\")\n        return 42\n\n    launcher.register_callable(ignore_errors(default_return=\"bla\")(raises_error))\n    return launcher\n\n\ndef create_fake_subjects():\n    subjects = [\"00000\", \"123456\"]\n    for subject in subjects:\n        os.makedirs(f\"{LIB_CONFIG}/Subjects/{subject}\", exist_ok=True)\n        with open(f\"{LIB_CONFIG}/Subjects/{subject}/task_logic.json\", \"w\", encoding=\"utf-8\") as f:\n            f.write(TaskLogicModel(task_parameters={\"subject\": subject}).model_dump_json(indent=2))\n        with open(f\"{LIB_CONFIG}/Subjects/{subject}/trainer_state.json\", \"w\", encoding=\"utf-8\") as f:\n            f.write(mock_trainer_state.model_dump_json(indent=2))\n\n\ndef create_fake_rig():\n    computer_name = os.getenv(\"COMPUTERNAME\")\n    os.makedirs(_dir := f\"{LIB_CONFIG}/Rig/{computer_name}\", exist_ok=True)\n    with open(f\"{_dir}/rig1.json\", \"w\", encoding=\"utf-8\") as f:\n        f.write(RigModel().model_dump_json(indent=2))\n\n\ndef main():\n    create_fake_subjects()\n    create_fake_rig()\n    launcher = make_launcher()\n    launcher.main()\n    return None\n\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"}]}